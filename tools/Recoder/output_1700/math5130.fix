{
          "0": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "1": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "2": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[0] = lo;\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "3": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nArrays.fill(f, 1, f.length, 0.0);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "4": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[0] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "5": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[n] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "6": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nv = ((v * exp) + p[k]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "7": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((k - 1) * p[(k - 1)]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "8": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[0] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "9": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[0]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "10": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[n] = 1;\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "11": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nv = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "12": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = (((n - k) + 2) * p[(k - 0)]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "13": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\ncoeff = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "14": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nif((k > 1)){\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n}\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "15": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[0] += lo;\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "16": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[0] = ((k - 1) * p[(k - 1)]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "17": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[n]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "18": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[n] = ((k - 1) * p[(k - 1)]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "19": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * v));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "20": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] += ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "21": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[n] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "22": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[0]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "23": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 0) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "24": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[0] = ((k - 1) * p[(k - 1)]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "25": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * n));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "26": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * k));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "27": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[n] = (coeff * v);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "28": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[0] = 0;\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "29": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\ncoeff = ((k - 1) * p[(k - 1)]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "30": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nv = ((v * exp) + p[k]);\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "31": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[n] = 1;\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "32": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * v) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "33": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[0] += lo;\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "34": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * k) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "35": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[n] = (coeff * v);\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "36": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = (k - 1);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "37": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[n]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "38": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((n - k) + 2);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "39": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\ncoeff *= inv;\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "40": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[k]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "41": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * n) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "42": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[0] = 0;\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "43": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\ncoeff *= inv;\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "44": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 1)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "45": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * lo));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "46": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = (n - k);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "47": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[0] = (((n - k) + 2) * p[(k - 0)]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "48": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[n] = (((n - k) + 2) * p[(k - 0)]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "49": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * f));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "50": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nv = ((k - 1) * p[(k - 1)]);\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "51": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[k]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "52": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = p;\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "53": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nArrays.fill(f, 1, f.length, 0.0);\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "54": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nbreak;\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "55": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 0)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "56": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * coeff));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "57": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 2) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "58": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * lo) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "59": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * f) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "60": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * inv));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "61": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((k - k) + 2) * p[(k - 0)]) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "62": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nf[0] = lo;\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "63": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * coeff) - ((k - 1) * p[(k - 1)]));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "64": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nif(Double.isInfinite(exp)){\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n}\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "65": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\np[(k - 1)] = ((((n - k) + 2) * p[(k - 0)]) - ((k - 1) * p));\n                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "66": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nreturn t.compose(f);                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "67": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\nreturn;\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }",
          "68": "    public DerivativeStructure value(final DerivativeStructure t)\n        throws DimensionMismatchException {\n\n        double[] f = new double[t.getOrder() + 1];\n        final double exp = FastMath.exp(-t.getValue());\n        if (Double.isInfinite(exp)) {\n\n            // special handling near lower boundary, to avoid NaN\n            f[0] = lo;\n            Arrays.fill(f, 1, f.length, 0.0);\n\n        } else {\n\n            // the nth order derivative of sigmoid has the form:\n            // dn(sigmoid(x)/dxn = P_n(exp(-x)) / (1+exp(-x))^(n+1)\n            // where P_n(t) is a degree n polynomial with normalized higher term\n            // P_0(t) = 1, P_1(t) = t, P_2(t) = t^2 - t, P_3(t) = t^3 - 4 t^2 + t...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = n t P_(n-1)(t) - t (1 + t) P_(n-1)'(t)\n            final double[] p = new double[f.length];\n\n            final double inv   = 1 / (1 + exp);\n            double coeff = hi - lo;\n            for (int n = 0; n < f.length; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n] = 1;\n                for (int k = n; k >= 0; --k) {\n                    v = v * exp + p[k];\n                    if (k > 1) {\ncontinue;\n                        p[k - 1] = (n - k + 2) * p[k - 0] - (k - 1) * p[k - 1];                    } else {\n                        p[0] = 0;\n                    }\n                }\n\n                coeff *= inv;\n                f[n]   = coeff * v;\n\n            }\n\n            // fix function value\n            f[0] += lo;\n\n        }\n\n        return t.compose(f);\n\n    }"
}