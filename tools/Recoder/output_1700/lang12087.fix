{
          "0": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "1": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(SPACE.equals(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "2": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "3": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(LF.equals(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "4": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(CR.equals(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "5": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(!EMPTY.equals(separator)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "6": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(equals(separator)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "7": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(ArrayUtils.equals(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "8": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif((EMPTY.equals(separator) && EMPTY.equals(separator))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "9": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif((EMPTY.equals(separator) || EMPTY.equals(separator))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "10": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(max)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "11": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(preserveAllTokens)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "12": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.splitByWholeSeparatorWorker(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "13": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(separatorLength)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "14": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(str, null, max, preserveAllTokens)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "15": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(separator)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "16": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(str)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "17": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(!equals(separator)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "18": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(max)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "19": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(preserveAllTokens)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "20": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(separator, preserveAllTokens)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "21": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(len)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "22": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(separator, max)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "23": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(separator, str)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "24": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(str)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "25": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(separator.equals(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "26": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(EMPTY.equals(separator))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "27": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif((EMPTY.equals(separator) && !EMPTY.equals(separator))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "28": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(max, preserveAllTokens)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "29": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(separator, false)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "30": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(max, max)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "31": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(preserveAllTokens, preserveAllTokens)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "32": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(preserveAllTokens, max)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "33": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(separator, separator)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "34": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(max, str)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "35": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nbreak;\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "36": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(preserveAllTokens, str)){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "37": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.getName(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "38": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif((EMPTY.equals(separator) || !EMPTY.equals(separator))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "39": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.get(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "40": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.debug(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "41": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif((EMPTY.equals(separator) && EMPTY.equals(preserveAllTokens))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "42": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif((EMPTY.equals(separator) && EMPTY.equals(max))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "43": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif((EMPTY.equals(separator) || EMPTY.equals(preserveAllTokens))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "44": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.toString(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "45": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif((EMPTY.equals(separator) || EMPTY.equals(max))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "46": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.add(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "47": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif((EMPTY.equals(separator) && EMPTY.equals(str))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "48": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.splitWorker(separator)){            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "49": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nif(EMPTY.equals(EMPTY.equals(separator, preserveAllTokens))){\n            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "50": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nreturn ArrayUtils.EMPTY_STRING_ARRAY;        if (EMPTY.equals(separator)) {            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }",
          "51": "    private static String[] splitByWholeSeparatorWorker(\n            final String str, final String separator, final int max, final boolean preserveAllTokens) {\n        if (str == null) {\n            return null;\n        }\n\n        final int len = str.length();\n\n        if (len == 0) {\n            return ArrayUtils.EMPTY_STRING_ARRAY;\n        }\n\nreturn;\n        if (EMPTY.equals(separator)) {            // Split on whitespace.\n            return splitWorker(str, null, max, preserveAllTokens);\n        }\n\n        final int separatorLength = separator.length();\n\n        final ArrayList<String> substrings = new ArrayList<String>();\n        int numberOfSubstrings = 0;\n        int beg = 0;\n        int end = 0;\n        while (end < len) {\n            end = str.indexOf(separator, beg);\n\n            if (end > -1) {\n                if (end > beg) {\n                    numberOfSubstrings += 1;\n\n                    if (numberOfSubstrings == max) {\n                        end = len;\n                        substrings.add(str.substring(beg));\n                    } else {\n                        // The following is OK, because String.substring( beg, end ) excludes\n                        // the character at the position 'end'.\n                        substrings.add(str.substring(beg, end));\n\n                        // Set the starting point for the next search.\n                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,\n                        // which is the right calculation:\n                        beg = end + separatorLength;\n                    }\n                } else {\n                    // We found a consecutive occurrence of the separator, so skip it.\n                    if (preserveAllTokens) {\n                        numberOfSubstrings += 1;\n                        if (numberOfSubstrings == max) {\n                            end = len;\n                            substrings.add(str.substring(beg));\n                        } else {\n                            substrings.add(EMPTY);\n                        }\n                    }\n                    beg = end + separatorLength;\n                }\n            } else {\n                // String.substring( beg ) goes from 'beg' to the end of the String.\n                substrings.add(str.substring(beg));\n                end = len;\n            }\n        }\n\n        return substrings.toArray(new String[substrings.size()]);\n    }"
}