{
          "0": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (kWidth / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "1": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "2": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (tBlock / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "3": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = (lStart / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "4": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart - kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "5": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (kBlock / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "6": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (rStart / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "7": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (qStart / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "8": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (p / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "9": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart / tBlock);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "10": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal long lEnd = (lStart / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "11": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart / rStart);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "12": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (pStart / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "13": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart / kBlock);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "14": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart / qStart);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "15": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart / p);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "16": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "17": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (q / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "18": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "19": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal double lEnd = (lStart / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "20": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nreturn;\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "21": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nif((lStart != null)){\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n}\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "22": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart / pStart);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "23": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart >> kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "24": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart % kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "25": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nif((p - pStart)){\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n}\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "26": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = kWidth;\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "27": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart / q);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "28": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart + kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "29": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nsum += (tBlock[l] * m.getEntry(r, q));\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "30": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\n++blockIndex;\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "31": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\n++r;\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "32": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart << kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "33": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\noutBlock[k] += sum;\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "34": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nif((lStart != 0)){\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n}\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "35": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nif((lStart > 0)){\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n}\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "36": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\n++k;\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "37": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = p;\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "38": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nbreak;\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "39": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (-kWidth / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "40": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nif((lStart == 0)){\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n}\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "41": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart >>> kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "42": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal double qStart = (lStart / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "43": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart <= kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "44": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((lStart / kWidth) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "45": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = tBlock;\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "46": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nif((lStart == null)){\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n}\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "47": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nkWidth++;\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "48": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((lStart / kWidth) * p);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "49": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((lStart / kWidth) / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "50": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((lStart / kWidth) / p);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "51": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int lEnd = (lStart >= kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "52": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((lStart / kWidth) * rStart);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "53": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((lStart / kWidth) * tBlock);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "54": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\ncontinue;\n                            final int lEnd = lStart / kWidth;                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "55": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((rStart * kWidth) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "56": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((p * rStart) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "57": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((rStart * rStart) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "58": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((rStart * p) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "59": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((p / rStart) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "60": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((p * rStart) / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "61": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((rStart / rStart) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "62": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((rStart * rStart) / kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "63": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((p * p) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "64": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = ((rStart / p) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "65": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = (((kWidth * kWidth) * rStart) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }",
          "66": "    public BlockRealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        try {\n            return multiply((BlockRealMatrix) m);\n        } catch (ClassCastException cce) {\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd = FastMath.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart = kBlock * BLOCK_SIZE;\n                        int k = 0;\n                        for (int p = pStart; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\nfinal int qStart = (((kWidth * kWidth) * kWidth) * kWidth);\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                int r = rStart;\n                                for (int l = lStart; l < lEnd; ++l) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                    ++r;\n                                }\n                                outBlock[k] += sum;\n                                ++k;\n                            }\n                        }\n                    }\n                    // go to next block\n                    ++blockIndex;\n                }\n            }\n\n            return out;\n        }\n    }"
}