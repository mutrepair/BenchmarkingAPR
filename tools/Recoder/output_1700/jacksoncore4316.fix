{
          "0": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (first / first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "1": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nreturn;\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "2": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length / first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "3": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "4": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length - first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "5": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\noutputBuffer = textBuffer.finishCurrentSegment();\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "6": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (second / first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "7": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\noutPtr += length;\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "8": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\noutPtr = 0;\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "9": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\ntextBuffer.setCurrentLength(outPtr);\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "10": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\noutPtr = second;\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "11": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nbreak;\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "12": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nSystem.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "13": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length >> first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "14": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\noutputBuffer[outPtr++] = c;\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "15": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (outputBuffer / first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "16": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nSystem.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "17": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (_quoteBuffer / first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "18": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (escCode / first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "19": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length / length);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "20": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length <= first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "21": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length >>> first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "22": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length * first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "23": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length % first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "24": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length / second);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "25": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif((length != null)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "26": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\ncontinue;\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "27": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length >= first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "28": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif((first > 0)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "29": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif((c < escCodeCount)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "30": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif(((outPtr + length) > outputBuffer.length)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "31": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = length;\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "32": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length / outputBuffer);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "33": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length / _quoteBuffer);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "34": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif((outPtr + length)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "35": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length / escCode);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "36": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length << first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "37": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif((++inPtr >= inputLen)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "38": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif((escCodes[c] != 0)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "39": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nlong second = (length / first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "40": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif((outPtr >= outputBuffer.length)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "41": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint first = (outputBuffer.length - outPtr);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "42": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length + first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "43": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif(((c < escCodeCount) && (escCodes[c] != 0))){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "44": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif((escCode < 0)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "45": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif((escCode != null)){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "46": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nif(true){\n                int second = length / first;                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n}\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "47": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = ((length / first) * first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "48": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nchar c = input.charAt(inPtr);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "49": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = ((length / first) / first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "50": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = ((length / first) * length);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "51": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = ((length / first) - first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "52": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (length * (length / first));\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "53": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (first * (length / first));\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "54": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = ((length / first) % first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "55": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (first / (length / first));\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "56": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = ((length / first) / length);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "57": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (first % first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "58": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (first - length);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "59": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (first - first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "60": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = (first / length);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "61": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = ((length * first) * first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "62": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = ((length * first) / first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }",
          "63": "    public char[] quoteAsString(String input)\n    {\n        TextBuffer textBuffer = _textBuffer;\n        if (textBuffer == null) {\n            // no allocator; can add if we must, shouldn't need to\n            _textBuffer = textBuffer = new TextBuffer(null);\n        }\n        char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment();\n        final int[] escCodes = CharTypes.get7BitOutputEscapes();\n        final int escCodeCount = escCodes.length;\n        int inPtr = 0;\n        final int inputLen = input.length();\n        int outPtr = 0;\n \n        outer_loop:\n        while (inPtr < inputLen) {\n            tight_loop:\n            while (true) {\n                char c = input.charAt(inPtr);\n                if (c < escCodeCount && escCodes[c] != 0) {\n                    break tight_loop;\n                }\n                if (outPtr >= outputBuffer.length) {\n                    outputBuffer = textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outputBuffer[outPtr++] = c;\n                if (++inPtr >= inputLen) {\n                    break outer_loop;\n                }\n            }\n            // something to escape; 2 or 6-char variant? \n            char d = input.charAt(inPtr++);\n            int escCode = escCodes[d];\n            int length = (escCode < 0)\n                    ? _appendNumericEscape(d, _quoteBuffer)\n                    : _appendNamedEscape(escCode, _quoteBuffer);\n                    ;\n            if ((outPtr + length) > outputBuffer.length) {\n                int first = outputBuffer.length - outPtr;\n                if (first > 0) {\n                    System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first);\n                }\n                outputBuffer = textBuffer.finishCurrentSegment();\nint second = ((length * length) * first);\n                System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second);\n                outPtr = second;\n            } else {\n                System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length);\n                outPtr += length;\n            }\n        }\n        textBuffer.setCurrentLength(outPtr);\n        return textBuffer.contentsAsArray();\n    }"
}