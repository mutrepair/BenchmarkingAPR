{
          "0": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nlong beta = (1.0 + secondary[(k - 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "1": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[(k - 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "2": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + householderVectors);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "3": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + main);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "4": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "5": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nint beta = (1.0 + secondary[(k - 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "6": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + inv);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "7": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nfinal double beta = (1.0 + secondary[(k - 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "8": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[(k - 0)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "9": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 - secondary[(k - 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "10": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nif((inv != null)){\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n}\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "11": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + householderVectors[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "12": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + main[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "13": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "14": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + householderVectors[j].[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "15": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + main[j].[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "16": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[j].[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "17": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nreturn;\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "18": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[(k - 2)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "19": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + qta[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "20": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + hK[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "21": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + qta[j].[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "22": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (k - 1);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "23": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[k].[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "24": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + hK[j].[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "25": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + beta);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "26": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + householderVectors[j].[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "27": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + main[j].[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "28": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[j].[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "29": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[k].[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "30": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nif((secondary[(k - 1)] * hK[k])){\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n}\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "31": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + qta[j].[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "32": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + qta[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "33": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + qta);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "34": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + hK[j].[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "35": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + hK);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "36": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + hK[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "37": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nif((inv == null)){\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n}\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "38": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + householderVectors[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "39": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + main[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "40": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "41": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + k[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "42": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + k[j].[i]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "43": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + k[j].[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "44": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + householderVectors[k].[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "45": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + main[k].[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "46": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ntransform();\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "47": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + k);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "48": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nqta[k].[i] = (beta * hK[i]);\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "49": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[(k + 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "50": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nbreak;\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "51": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (beta * hK[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "52": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nif((secondary != null)){\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n}\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "53": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "54": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nbeta += (qta[j].[i] * hK[i]);\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "55": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nqta[j].[i] += (beta * hK[i]);\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "56": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nqta[k].[k] = (1 + (beta * hK[k]));\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "57": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nbeta = 0;\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "58": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nif((inv == 0)){\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n}\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "59": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 / secondary[(k - 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "60": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nfinal double inv = (1.0 / (secondary[(k - 1)] * hK[k]));\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "61": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[(k / 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "62": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nqta[j].[k] = (beta * hK[k]);\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "63": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nbeta *= inv;\n                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "64": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 * secondary[(k - 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "65": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = (1.0 + secondary[(k * 1)]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "66": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = ((1.0 + secondary[(k - 1)]) + 1);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "67": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nfor(int i = (k + 1);(i < m);++i) {                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "68": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\nfor(int j = (k + 1);(j < m);++j) {                    double beta = 1.0 + secondary[k - 1];                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
          "69": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\ndouble beta = ((1.0 + secondary[(k - 1)]) + secondary[0]);\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }"
}