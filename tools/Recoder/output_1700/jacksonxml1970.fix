{
          "0": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nreturn;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "1": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "2": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nser.serialize(value, gen, this);\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "3": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\n_initWithRootName(xgen, rootName);\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "4": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\n_serializeXmlNull(gen);\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "5": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nasArray = TypeUtil.isIndexedType(cls);\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "6": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nasArray = false;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "7": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nmsg = ((\"null\" + e.getClass().getName()) + \"null\");\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "8": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\n_startRootArray(xgen, rootName);\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "9": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\ngen.writeEndObject();\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "10": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nrootName = _rootNameLookup.findRootName(cls, _config);\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "11": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nbreak;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "12": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(xgen){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "13": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nasArray = asArray;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "14": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nasArray = true;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "15": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(cls){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "16": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nasArray = null;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "17": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(_config){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "18": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif((\"null\" + e.getClass().getName())){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "19": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(gen){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "20": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(ioe){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "21": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(!xgen){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "22": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif((\"null\" + e.getClass().getName())){\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n}\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "23": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(!asArray){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "24": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nasArray = cls;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "25": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(asArray){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "26": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nasArray = gen;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "27": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\ncontinue;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "28": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nasArray++;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "29": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(-true){                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "30": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(rootName){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "31": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nbreak;\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "32": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif((asArray != null)){\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n}\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "33": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(asArray){\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n}\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "34": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif((msg == null)){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "35": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif((rootName == null)){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "36": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(true){                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "37": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif((value == null)){\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "38": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif((msg == null)){\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n}\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "39": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif((value == null)){\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n}\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "40": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif((rootName == null)){\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n}\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "41": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(null){                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "42": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(false){                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "43": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nreturn;\nreturn;\n            if (false) {                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "44": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\ncontinue;\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "45": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nreturn;\n                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }",
          "46": "    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n        if (xgen == null) { // called by convertValue()\n            asArray = false;\n        } else {\n            QName rootName = _rootNameFromConfig();\n            if (rootName == null) {\n                rootName = _rootNameLookup.findRootName(cls, _config);\n            }\n            _initWithRootName(xgen, rootName);\n            asArray = TypeUtil.isIndexedType(cls);\nif(\"null\"){                _startRootArray(xgen, rootName);\n            }\n        }\n        \n        // From super-class implementation\n        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n        try {\n            ser.serialize(value, gen, this);\n        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n            throw ioe;\n        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n            String msg = e.getMessage();\n            if (msg == null) {\n                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n            }\n            throw JsonMappingException.from(gen, msg, e);\n        }\n        // end of super-class implementation\n\n        if (asArray) {\n            gen.writeEndObject();\n        }\n    }"
}