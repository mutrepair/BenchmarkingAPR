{
          "0": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (ge + 0);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "1": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nszptr = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "2": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "3": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = gs;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "4": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nrfreq = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "5": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "6": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nbt = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "7": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs += (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "8": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (i <= ge);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "9": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (ge + 1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "10": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ni = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "11": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nwrite(gs);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "12": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nbsPutUChar(gs);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "13": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nbsPutint(gs);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "14": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n-gs = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "15": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n-szptr = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "16": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs[szptr[i]] = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "17": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (szptr + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "18": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (ge + 2);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "19": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs[bt] = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "20": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (bt + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "21": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nszptr[bt].[szptr[i]] = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "22": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs[bt].[szptr[i]] = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "23": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = ((ge + -1) + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "24": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nszptr[i] = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "25": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (i + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "26": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs[i] = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "27": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n-rfreq = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "28": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (gs + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "29": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (gs + gs);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "30": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (rfreq + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "31": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n-bt = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "32": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nrfreq[bt].[szptr[i]] = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "33": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "34": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nrfreq[i] = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "35": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\n-i = (ge + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "36": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = ((ge + -1) + 0);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "37": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = ((ge + -1) + 1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "38": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nrfreq[bt].[szptr[i]]++;\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "39": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (ge - -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "40": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (gs + 1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "41": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (gs + 0);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "42": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (ge == -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "43": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nbreak;\n                gs = ge + -1;            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "44": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = ((gs + gs) + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "45": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (ge <= -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "46": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = ((gs + gs) + ge);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "47": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = ((gs + -1) + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "48": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = ((gs + -1) + gs);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "49": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (ge >= -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "50": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = ((gs + gs) + gs);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "51": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nrfreq[bt].[szptr[i]]++;\n                gs = ge + -1;            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "52": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = ((ge + gs) + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "53": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\nreturn;\n                gs = ge + -1;            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "54": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ncontinue;\n                gs = ge + -1;            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }",
          "55": "    private void sendMTFValues() throws IOException {\n        char len[][] = new char[N_GROUPS][MAX_ALPHA_SIZE];\n\n        int v, t, i, j, gs, ge, totc, bt, bc, iter;\n        int nSelectors = 0, alphaSize, minLen, maxLen, selCtr;\n        int nGroups; //, nBytes;\n\n        alphaSize = nInUse + 2;\n        for (t = 0; t < N_GROUPS; t++) {\n            for (v = 0; v < alphaSize; v++) {\n                len[t][v] = (char) GREATER_ICOST;\n            }\n        }\n\n        /* Decide how many coding tables to use */\n        if (nMTF <= 0) {\n            panic();\n        }\n\n        if (nMTF < 200) {\n            nGroups = 2;\n        } else if (nMTF < 600) {\n            nGroups = 3;\n        } else if (nMTF < 1200) {\n            nGroups = 4;\n        } else if (nMTF < 2400) {\n            nGroups = 5;\n        } else {\n            nGroups = 6;\n        }\n\n        /* Generate an initial set of coding tables */ {\n            int nPart, remF, tFreq, aFreq;\n\n            nPart = nGroups;\n            remF  = nMTF;\n            gs = 0;\n            while (nPart > 0) {\n                tFreq = remF / nPart;\n                ge = gs - 1;\n                aFreq = 0;\n                while (aFreq < tFreq && ge < alphaSize - 1) {\n                    ge++;\n                    aFreq += mtfFreq[ge];\n                }\n\n                if (ge > gs && nPart != nGroups && nPart != 1\n                    && ((nGroups - nPart) % 2 != 0)) {\n                    aFreq -= mtfFreq[ge];\n                    ge--;\n                }\n\n                for (v = 0; v < alphaSize; v++) {\n                    if (v >= gs && v <= ge) {\n                        len[nPart - 1][v] = (char) LESSER_ICOST;\n                    } else {\n                        len[nPart - 1][v] = (char) GREATER_ICOST;\n                    }\n                }\n\n                nPart--;\n                gs = ge + 1;\n                remF -= aFreq;\n            }\n        }\n\n        int[][] rfreq = new int[N_GROUPS][MAX_ALPHA_SIZE];\n        int[] fave = new int[N_GROUPS];\n        short[] cost = new short[N_GROUPS];\n        /*\n          Iterate up to N_ITERS times to improve the tables.\n        */\n        for (iter = 0; iter < N_ITERS; iter++) {\n            for (t = 0; t < nGroups; t++) {\n                fave[t] = 0;\n            }\n\n            for (t = 0; t < nGroups; t++) {\n                for (v = 0; v < alphaSize; v++) {\n                    rfreq[t][v] = 0;\n                }\n            }\n\n            nSelectors = 0;\n            totc = 0;\n            gs = 0;\n            while (true) {\n\n                /* Set group start & end marks. */\n                if (gs >= nMTF) {\n                    break;\n                }\n                ge = gs + G_SIZE - 1;\n                if (ge >= nMTF) {\n                    ge = nMTF - 1;\n                }\n\n                /*\n                  Calculate the cost of this group as coded\n                  by each of the coding tables.\n                */\n                for (t = 0; t < nGroups; t++) {\n                    cost[t] = 0;\n                }\n\n                if (nGroups == 6) {\n                    short cost0, cost1, cost2, cost3, cost4, cost5;\n                    cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        cost0 += len[0][icv];\n                        cost1 += len[1][icv];\n                        cost2 += len[2][icv];\n                        cost3 += len[3][icv];\n                        cost4 += len[4][icv];\n                        cost5 += len[5][icv];\n                    }\n                    cost[0] = cost0;\n                    cost[1] = cost1;\n                    cost[2] = cost2;\n                    cost[3] = cost3;\n                    cost[4] = cost4;\n                    cost[5] = cost5;\n                } else {\n                    for (i = gs; i <= ge; i++) {\n                        short icv = szptr[i];\n                        for (t = 0; t < nGroups; t++) {\n                            cost[t] += len[t][icv];\n                        }\n                    }\n                }\n\n                /*\n                  Find the coding table which is best for this group,\n                  and record its identity in the selector table.\n                */\n                bc = 999999999;\n                bt = -1;\n                for (t = 0; t < nGroups; t++) {\n                    if (cost[t] < bc) {\n                        bc = cost[t];\n                        bt = t;\n                    }\n                }\n                totc += bc;\n                fave[bt]++;\n                selector[nSelectors] = (char) bt;\n                nSelectors++;\n\n                /*\n                  Increment the symbol frequencies for the selected table.\n                */\n                for (i = gs; i <= ge; i++) {\n                    rfreq[bt][szptr[i]]++;\n                }\n\ngs = (((gs + gs) + -1) + -1);\n            }\n\n            /*\n              Recompute the tables based on the accumulated frequencies.\n            */\n            for (t = 0; t < nGroups; t++) {\n                hbMakeCodeLengths(len[t], rfreq[t], alphaSize, 20);\n            }\n        }\n\n        rfreq = null;\n        fave = null;\n        cost = null;\n\n        if (!(nGroups < 8)) {\n            panic();\n        }\n        if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / G_SIZE)))) {\n            panic();\n        }\n\n\n        /* Compute MTF values for the selectors. */\n        {\n            char[] pos = new char[N_GROUPS];\n            char ll_i, tmp2, tmp;\n            for (i = 0; i < nGroups; i++) {\n                pos[i] = (char) i;\n            }\n            for (i = 0; i < nSelectors; i++) {\n                ll_i = selector[i];\n                j = 0;\n                tmp = pos[j];\n                while (ll_i != tmp) {\n                    j++;\n                    tmp2 = tmp;\n                    tmp = pos[j];\n                    pos[j] = tmp2;\n                }\n                pos[0] = tmp;\n                selectorMtf[i] = (char) j;\n            }\n        }\n\n        int[][] code = new int[N_GROUPS][MAX_ALPHA_SIZE];\n\n        /* Assign actual codes for the tables. */\n        for (t = 0; t < nGroups; t++) {\n            minLen = 32;\n            maxLen = 0;\n            for (i = 0; i < alphaSize; i++) {\n                if (len[t][i] > maxLen) {\n                    maxLen = len[t][i];\n                }\n                if (len[t][i] < minLen) {\n                    minLen = len[t][i];\n                }\n            }\n            if (maxLen > 20) {\n                panic();\n            }\n            if (minLen < 1) {\n                panic();\n            }\n            hbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n        }\n\n        /* Transmit the mapping table. */\n        {\n            boolean[] inUse16 = new boolean[16];\n            for (i = 0; i < 16; i++) {\n                inUse16[i] = false;\n                for (j = 0; j < 16; j++) {\n                    if (inUse[i * 16 + j]) {\n                        inUse16[i] = true;\n                    }\n                }\n            }\n\n            //nBytes = bytesOut;\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    bsW(1, 1);\n                } else {\n                    bsW(1, 0);\n                }\n            }\n\n            for (i = 0; i < 16; i++) {\n                if (inUse16[i]) {\n                    for (j = 0; j < 16; j++) {\n                        if (inUse[i * 16 + j]) {\n                            bsW(1, 1);\n                        } else {\n                            bsW(1, 0);\n                        }\n                    }\n                }\n            }\n\n        }\n\n        /* Now the selectors. */\n        //nBytes = bytesOut;\n        bsW (3, nGroups);\n        bsW (15, nSelectors);\n        for (i = 0; i < nSelectors; i++) {\n            for (j = 0; j < selectorMtf[i]; j++) {\n                bsW(1, 1);\n            }\n            bsW(1, 0);\n        }\n\n        /* Now the coding tables. */\n        //nBytes = bytesOut;\n\n        for (t = 0; t < nGroups; t++) {\n            int curr = len[t][0];\n            bsW(5, curr);\n            for (i = 0; i < alphaSize; i++) {\n                while (curr < len[t][i]) {\n                    bsW(2, 2);\n                    curr++; /* 10 */\n                }\n                while (curr > len[t][i]) {\n                    bsW(2, 3);\n                    curr--; /* 11 */\n                }\n                bsW (1, 0);\n            }\n        }\n\n        /* And finally, the block data proper */\n        //nBytes = bytesOut;\n        selCtr = 0;\n        gs = 0;\n        while (true) {\n            if (gs >= nMTF) {\n                break;\n            }\n            ge = gs + G_SIZE - 1;\n            if (ge >= nMTF) {\n                ge = nMTF - 1;\n            }\n            for (i = gs; i <= ge; i++) {\n                bsW(len[selector[selCtr]][szptr[i]],\n                    code[selector[selCtr]][szptr[i]]);\n            }\n\n            gs = ge + 1;\n            selCtr++;\n        }\n        if (!(selCtr == nSelectors)) {\n            panic();\n        }\n    }"
}