{
          "0": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((mant.length % 1)){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "1": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nbreak;\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "2": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length % 0)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "3": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.RADIX == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "4": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.MIN_EXP == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "5": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.MAX_EXP == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "6": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.ERR_SCALE == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "7": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "8": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.exp == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "9": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\ndx = dx.divide(2);\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "10": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nx = x.add(dx);\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "11": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nppx = px;\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "12": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\npx = x;\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "13": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\ndx = dx.add(this.divide(x));\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "14": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\ndx = newInstance(x);\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "15": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\ndx.sign = -1;\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "16": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((RADIX.mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "17": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((MIN_EXP.mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "18": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((MAX_EXP.mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "19": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((ERR_SCALE.mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "20": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((mant.mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "21": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((exp.mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "22": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((getRadixDigits().mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "23": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((hashCode().mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "24": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((intValue().mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "25": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((log10K().mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "26": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((intLog10().mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "27": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((classify().mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "28": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((log10().mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "29": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nshiftLeft();\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n}\n        }\n\n        return x;\n\n    }",
          "30": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nshiftRight();\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n}\n        }\n\n        return x;\n\n    }",
          "31": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length % 1)] == 0)){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "32": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nreturn x;            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "33": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "34": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nreturn null;            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "35": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((RADIX.length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "36": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((MIN_EXP.length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "37": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((MAX_EXP.length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "38": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((ERR_SCALE.length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "39": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((mant.length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "40": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((exp.length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "41": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((getRadixDigits().length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "42": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((hashCode().length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "43": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((intValue().length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "44": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((log10K().length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "45": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((intLog10().length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "46": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((classify().length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "47": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((log10().length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "48": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length % 2)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "49": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "50": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length % 1)] >= 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "51": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((RADIX == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "52": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((MIN_EXP == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "53": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((MAX_EXP == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "54": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((ERR_SCALE == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "55": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((mant == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "56": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((exp == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "57": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.length == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "58": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length % 1)] != 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "59": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(((dx.mant[(mant.length % 1)] == 0) && (dx.mant[(mant.length % 1)] == 0))){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "60": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(x.equals(ppx)){\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n}\n        }\n\n        return x;\n\n    }",
          "61": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((RADIX.mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "62": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((MIN_EXP.mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "63": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((MAX_EXP.mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "64": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((ERR_SCALE.mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "65": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((mant.mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "66": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((exp.mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "67": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((getRadixDigits().mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "68": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((hashCode().mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "69": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((intValue().mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "70": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((log10K().mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "71": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((intLog10().mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "72": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((classify().mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "73": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((log10().mant[(mant.length % 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "74": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length % 1)] <= 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "75": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((mant.length % 1)){\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n}\n        }\n\n        return x;\n\n    }",
          "76": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(negativeOrNull()){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "77": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(strictlyNegative()){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "78": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(positiveOrNull()){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "79": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(strictlyPositive()){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "80": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(isInfinite()){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "81": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(isNaN()){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "82": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(isZero()){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "83": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nx.shiftLeft();\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n}\n        }\n\n        return x;\n\n    }",
          "84": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nx.shiftRight();\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n}\n        }\n\n        return x;\n\n    }",
          "85": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length % 1)] > 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "86": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length >= 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "87": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(x.equals(ppx)){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "88": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\ncontinue;\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "89": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length == 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "90": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length != 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "91": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(((dx.mant[(mant.length % 1)] == 0) && (mant.length % 1))){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "92": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(((dx.mant[(mant.length % 1)] == 0) || (dx.mant[(mant.length % 1)] == 0))){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "93": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "94": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nreturn;\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "95": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length <= 1)] == 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "96": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nbreak;\nbreak;\n            if (dx.mant[mant.length % 1] == 0) {                break;\n            }\n        }\n\n        return x;\n\n    }",
          "97": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nx = x.add(dx);\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "98": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\ndx = dx.divide(2);\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "99": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif((dx.mant[(mant.length % 1)] < 0)){                break;\n            }\n        }\n\n        return x;\n\n    }",
          "100": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(((dx.mant[(mant.length % 1)] == 0) && (dx.mant == 0))){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "101": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(((dx.mant[(mant.length % 1)] == 0) && (dx.mant == dx.mant))){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "102": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(((dx.mant[(mant.length % 1)] == 0) && ((dx.mant[(mant.length % 1)] == 0) && (dx.mant == dx.mant)))){\n                break;\n            }\n        }\n\n        return x;\n\n    }",
          "103": "    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\nif(((dx.mant[(mant.length % 1)] == 0) && ((dx.mant[(mant.length % 1)] == 0) && (dx.mant != dx.mant)))){\n                break;\n            }\n        }\n\n        return x;\n\n    }"
}