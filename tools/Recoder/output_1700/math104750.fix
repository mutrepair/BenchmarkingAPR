{
          "0": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, 0, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "1": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, 0, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "2": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "3": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, 1.0, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "4": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, 1.0, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "5": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, 2, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "6": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, 2, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "7": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nreturn;\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "8": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, false, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "9": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, false, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "10": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, true, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "11": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, true, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "12": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nxrow[0] = 1.0;\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "13": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nclear();\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "14": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\ntolset();\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "15": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nsingcheck();\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "16": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nss();\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "17": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nxrow = new double[(row_data.length + 1)];\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "18": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, 1, row_data);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "19": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, 1, xrow);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "20": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nxrow = row_data;\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "21": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, null, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "22": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, null, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "23": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.clear();\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "24": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.tolset();\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "25": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.singcheck();\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "26": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.ss();\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "27": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "28": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(xrow, -1, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "29": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, -1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "30": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, row_data, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "31": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nxrow = new double[(row_data.length + 1)];\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "32": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, 1, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "33": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy();\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "34": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, 1, -xrow);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "35": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, 1, -row_data);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "36": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "37": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nif(this.hasIntercept){\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n}\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "38": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\narraycopy(row_data, -1, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "39": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nif((xrow != null)){\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n}\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "40": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -2, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "41": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nxrow = row_data;\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "42": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, -2, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "43": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nxrow[0] = 1.0;\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "44": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(xrow);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "45": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, \"null\", xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "46": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, -1, xrow, \"null\", row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "47": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "48": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nbreak;\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "49": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.debug(row_data, -1, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "50": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nrow_data.arraycopy(row_data, -1, xrow, 1, row_data.length);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "51": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\ncontinue;\n            System.arraycopy(row_data, -1, xrow, 1, row_data.length);        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "52": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, -1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "53": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, 1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "54": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, -1, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "55": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, 1, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "56": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, row_data, xrow, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "57": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, row_data, xrow, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "58": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, -1, -1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "59": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, 1, -1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "60": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, -1, 1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "61": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, 1, 1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "62": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, -1, -1, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "63": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, 1, -1, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "64": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, -1, 1, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "65": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, 1, 1, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "66": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, row_data, xrow, -1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "67": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, row_data, xrow, 1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "68": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, row_data, xrow, -1, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "69": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data.length, row_data, xrow, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "70": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, row_data, xrow, 1, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "71": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data.length, row_data, xrow, 1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "72": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, -1, -1, -1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "73": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, 1, -1, -1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "74": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, xrow, -1, 1, -1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }",
          "75": "    public double getDiagonalOfHatMatrix(double[] row_data) {\n        double[] wk = new double[this.nvars];\n        int pos;\n        double total;\n\n        if (row_data.length > nvars) {\n            return Double.NaN;\n        }\n        double[] xrow;\n        if (this.hasIntercept) {\n            xrow = new double[row_data.length + 1];\n            xrow[0] = 1.0;\nSystem.arraycopy(row_data, row_data, xrow, -1, -1, -1);\n        } else {\n            xrow = row_data;\n        }\n        double hii = 0.0;\n        for (int col = 0; col < xrow.length; col++) {\n            if (Math.sqrt(d[col]) < tol[col]) {\n                wk[col] = 0.0;\n            } else {\n                pos = col - 1;\n                total = xrow[col];\n                for (int row = 0; row < col; row++) {\n                    total = smartAdd(total, -wk[row] * r[pos]);\n                    pos += nvars - row - 2;\n                }\n                wk[col] = total;\n                hii = smartAdd(hii, (total * total) / d[col]);\n            }\n        }\n        return hii;\n    }"
}