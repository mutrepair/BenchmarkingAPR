{
          "0": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "1": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) - xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "2": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((est * est) * xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "3": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * err) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "4": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) * err));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "5": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * cotanFlag) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "6": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) * cotanFlag));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "7": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * xbadj) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "8": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * sina) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "9": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) * sina));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "10": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (est * est);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "11": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb + ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "12": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) + xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "13": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * xb) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "14": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) * xbadj));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "15": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb / ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "16": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb * ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "17": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) / xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "18": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb % ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "19": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) % xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "20": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nfinal double xbadj = (xb - ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "21": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nerr += xbadj;\n            double xbadj = xb - est * est * xb;            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "22": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = xb;\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "23": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nxbadj = -xbadj;\n            double xbadj = xb - est * est * xb;            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "24": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nif((xb != 0.0)){\n            double xbadj = xb - est * est * xb;            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n}\n        }\n\n        return est+err;\n    }",
          "25": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nlong xbadj = (xb - ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "26": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nerr += (((-sina * cosb) / cosa) / cosa);\n            double xbadj = xb - est * est * xb;            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "27": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb <= ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "28": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) >> xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "29": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) <= xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "30": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb & ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "31": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb >> ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "32": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nif(cotanFlag){\n            double xbadj = xb - est * est * xb;            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n}\n        }\n\n        return est+err;\n    }",
          "33": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb << ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "34": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) & xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "35": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nreturn (est + err);            double xbadj = xb - est * est * xb;            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "36": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb | ((est * est) * xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "37": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) << xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "38": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (xb - ((est * est) >= xb));\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "39": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nbreak;\n            double xbadj = xb - est * est * xb;            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "40": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\nreturn;\n            double xbadj = xb - est * est * xb;            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "41": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((xb * xb) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "42": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((est * xb) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "43": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((xb * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "44": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((est * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "45": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((xb * xb) * xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "46": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((est * xb) * xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "47": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((xb * est) * xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "48": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\n            double xbadj = xb - est * est * xb;            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "49": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (((xb * xb) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "50": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (((xb * xb) * xb) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "51": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (((xb * est) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "52": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (((est * est) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "53": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = (((est * xb) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "54": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((est * est) * est) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "55": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((est * est) * est) * est) * xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "56": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((est * xb) * est) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "57": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((xb * est) * est) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "58": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((xb * xb) * est) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "59": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((xb * xb) * xb) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "60": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((est * est) * est) * xb) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "61": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((est * xb) * est) * est) * xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "62": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((est * est) * xb) * est) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "63": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((xb * xb) * est) * xb) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }",
          "64": "    private static double tanQ(double xa, double xb, boolean cotanFlag) {\n\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        // Compute sine\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA*cosEpsB + costA*sinEpsB;\n        b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        double sina = a + b;\n        double sinb = -(sina - a - b);\n\n        // Compute cosine\n\n        a = b = c = d = 0.0;\n\n        t = costA*cosEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = -sintA*sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n        b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n\n        double cosa = a + b;\n        double cosb = -(cosa - a - b);\n\n        if (cotanFlag) {\n            double tmp;\n            tmp = cosa; cosa = sina; sina = tmp;\n            tmp = cosb; cosb = sinb; sinb = tmp;\n        }\n\n\n        /* estimate and correct, compute 1.0/(cosa+cosb) */\n        /*\n    double est = (sina+sinb)/(cosa+cosb);\n    double err = (sina - cosa*est) + (sinb - cosb*est);\n    est += err/(cosa+cosb);\n    err = (sina - cosa*est) + (sinb - cosb*est);\n         */\n\n        // f(x) = 1/x,   f'(x) = -1/x^2\n\n        double est = sina/cosa;\n\n        /* Split the estimate to get more accurate read on division rounding */\n        temp = est * HEX_40000000;\n        double esta = (est + temp) - temp;\n        double estb =  est - esta;\n\n        temp = cosa * HEX_40000000;\n        double cosaa = (cosa + temp) - temp;\n        double cosab =  cosa - cosaa;\n\n        //double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n        double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n        err += sinb/cosa;                     // Change in est due to sinb\n        err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n\n        if (xb != 0.0) {\n            // tan' = 1 + tan^2      cot' = -(1 + cot^2)\n            // Approximate impact of xb\ndouble xbadj = ((((xb * xb) * xb) * xb) - xb);\n            if (cotanFlag) {\n                xbadj = -xbadj;\n            }\n\n            err += xbadj;\n        }\n\n        return est+err;\n    }"
}