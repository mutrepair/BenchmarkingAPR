{
          "0": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() >= 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "1": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(0):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "2": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() <= 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "3": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "4": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(2):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "5": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.getTypeFactory();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "6": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.getTypeFactory() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "7": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "8": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() == 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "9": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.getName();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "10": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.isPrimitive();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "11": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() < 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "12": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.getName() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "13": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.findDefaultDeserializer() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "14": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.isPrimitive() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "15": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.findDefaultDeserializer();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "16": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.getRawClass();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "17": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.containedTypeCount();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "18": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?tf.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "19": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() != 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "20": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = type.containedType(1);\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "21": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?clsName.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "22": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.getTypeFactory(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "23": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?elemType.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "24": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = (JavaType)TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "25": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?ctxt.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "26": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.findDefaultDeserializer(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "27": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.isPrimitive(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "28": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.getRawClass() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "29": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?rawType.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "30": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 1))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "31": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):rawType.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "32": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.toString();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "33": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):ctxt.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "34": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):type.containedType(1);\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "35": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):type.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "36": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() >>> 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "37": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.toString() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "38": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = (JavaType)type.containedType(1);\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "39": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() >> 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "40": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nif((tf != 0)){\n                JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(1) : TypeFactory.unknownType();                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n}\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "41": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?TypeFactory.unknownType():TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "42": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.getRawClass(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "43": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = new JavaType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "44": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(false):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "45": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 2))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "46": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.get();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "47": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() - 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "48": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.startsWith(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "49": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):DateDeserializers.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "50": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?beanDesc.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "51": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nfinal JavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "52": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.get() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "53": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.getName(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "54": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedTypeCount(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "55": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = (TypeFactory.unknownType())?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "56": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):NumberDeserializers.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "57": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(-1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "58": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = type.containedTypeCount();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "59": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):JdkDeserializers.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "60": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?JdkDeserializers.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "61": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):JacksonDeserializers.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "62": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?deser.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "63": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.get(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "64": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):beanDesc.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "65": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):clsName.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "66": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(true):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "67": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\ndeser = DateDeserializers.find(rawType, clsName);\n                JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(1) : TypeFactory.unknownType();                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "68": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\ndeser = JdkDeserializers.find(rawType, clsName);\n                JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(1) : TypeFactory.unknownType();                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "69": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((DateDeserializers.containedTypeCount() > 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "70": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type == 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "71": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() * 0))?type.containedType(1):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "72": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nClass<?> rawType = type.getRawClass();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "73": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nString clsName = rawType.getName();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "74": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nreturn UntypedObjectDeserializer.instance;                JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(1) : TypeFactory.unknownType();                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "75": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nreturn StringDeserializer.instance;                JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(1) : TypeFactory.unknownType();                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "76": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(null):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "77": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):TypeFactory.containedType(type);\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "78": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):type.containedType(0);\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "79": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?TypeFactory.containedType(type):TypeFactory.unknownType();\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }",
          "80": "    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n            JavaType type, BeanDescription beanDesc)\n        throws JsonMappingException\n    {\n        Class<?> rawType = type.getRawClass();\n        String clsName = rawType.getName();\n        if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n            // Object (\"untyped\"), String equivalents:\n            if (rawType == CLASS_OBJECT) {\n                return UntypedObjectDeserializer.instance;\n            }\n            if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                return StringDeserializer.instance;\n            }\n            if (rawType == CLASS_ITERABLE) {\n                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n                TypeFactory tf = ctxt.getTypeFactory();\nJavaType elemType = ((type.containedTypeCount() > 0))?type.containedType(1):type.containedType(type);\n                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n                // Should we re-introspect beanDesc? For now let's not...\n                return createCollectionDeserializer(ctxt, ct, beanDesc);\n            }\n            // Primitives/wrappers, other Numbers:\n            JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n            if (deser == null) {\n                deser = DateDeserializers.find(rawType, clsName);\n                if (deser == null) {\n                    deser = JdkDeserializers.find(rawType, clsName);\n                }\n            }\n            return deser;\n        }\n        if (clsName.startsWith(\"com.fasterxml.\")) {\n            // and a few Jackson types as well:\n            return JacksonDeserializers.find(rawType);\n        }\n        return null;\n    }"
}