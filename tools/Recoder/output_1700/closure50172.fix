{
          "0": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(isCaseSensitive()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "1": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(containsAnchor()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "2": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(hasCapturingGroup()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "3": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(simplest){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "4": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(groupName){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "5": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(DecomposedCharset.isCaseSensitive()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "6": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(DecomposedCharset.containsAnchor()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "7": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(DecomposedCharset.hasCapturingGroup()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "8": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(ieExplicits){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "9": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(rangesInterIeExplicits){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "10": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "11": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(namedGroups){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "12": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nbreak;\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "13": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(!isCaseSensitive()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "14": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(!containsAnchor()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "15": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(!hasCapturingGroup()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "16": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((complexity != null)){\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n}\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "17": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\ngroupName = namedGroup.getKey().charValue();\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "18": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(!simplest){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "19": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nranges = simplest;\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "20": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nnamedGroups.append(\"null\").append(groupName);\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "21": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((simplest != null)){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "22": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nminComplexity = complexity;\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "23": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(minComplexity){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "24": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(NAMED_CHAR_GROUPS.entrySet()){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "25": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(ranges){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "26": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(namedGroup){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "27": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(e){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "28": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((minComplexity != null)){\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n}\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "29": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nsimplest = withoutGroup;\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "30": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nreturn new DecomposedCharset(inverted, ranges, namedGroups.toString());            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "31": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nbreak;\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "32": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(-true){              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "33": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((namedGroup != null)){\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n}\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "34": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(ranges.containsAll(group)){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "35": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((namedGroup != null)){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "36": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((group != null)){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "37": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((withoutGroup != null)){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "38": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\n(Map namedGroup = ;\n:NAMED_CHAR_GROUPS.entrySet())            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "39": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nreturn;\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "40": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((group != null)){\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n}\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "41": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((simplest != null)){\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n}\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "42": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\ncontinue;\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "43": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((complexity == null)){\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n}\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "44": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\ncomplexity = false;\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "45": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\ncomplexity = true;\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "46": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(ranges.containsAll(group)){\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n}\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "47": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(false){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "48": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(false){              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "49": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(true){\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n}\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "50": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(true){              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "51": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(\"null\"){              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "52": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nint complexity = DecomposedCharset.complexity(withoutGroup);\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "53": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(null){              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "54": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\ncontinue;\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "55": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nCharRanges group = namedGroup.getValue();\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "56": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(((namedGroup != null) && (simplest != null))){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "57": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nCharRanges withoutGroup = ranges.difference(group).union(rangesInterIeExplicits);\n            if (false) {              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n}\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "58": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(0){              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "59": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(((minComplexity != null) && (simplest != null))){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "60": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif(((withoutGroup != null) && (simplest != null))){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "61": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((withoutGroup && (withoutGroup != null))){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }",
          "62": "    private DecomposedCharset decompose(CharRanges ranges, boolean inverted) {\n      StringBuilder namedGroups = new StringBuilder();\n      CharRanges rangesInterIeExplicits = ranges.intersection(ieExplicits);\n      while (true) {\n        char groupName = 0;\n        CharRanges simplest = null;\n        int minComplexity = DecomposedCharset.complexity(ranges);\n        for (Map.Entry<Character, CharRanges> namedGroup\n             : NAMED_CHAR_GROUPS.entrySet()) {\n          CharRanges group = namedGroup.getValue();\n          if (ranges.containsAll(group)) {\n            CharRanges withoutGroup = ranges.difference(group).union(\n                rangesInterIeExplicits);\n            int complexity = DecomposedCharset.complexity(withoutGroup);\nif((group && (withoutGroup != null))){\n              simplest = withoutGroup;\n              groupName = namedGroup.getKey().charValue();\n              minComplexity = complexity;\n            }\n          }\n        }\n        if (simplest != null) {\n          namedGroups.append('\\\\').append(groupName);\n          ranges = simplest;\n        } else {\n          break;\n        }\n      }\n      return new DecomposedCharset(inverted, ranges, namedGroups.toString());\n    }"
}