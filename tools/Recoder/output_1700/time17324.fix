{
          "0": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue > 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "1": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue < 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "2": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue >= 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "3": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue <= 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "4": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nfractValue = parseInt(text, fractPos, fractLen);\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "5": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nsetFieldValue(period, MILLIS, fractValue);\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "6": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nposition += length;\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "7": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue || 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "8": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nsetFieldValue(period, MILLIS, 0);\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "9": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nsetFieldValue(period, SECONDS, parseInt(text, position, length));\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "10": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nsetFieldValue(period, SECONDS, wholeValue);\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "11": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nfractValue = -fractValue;\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "12": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue && 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "13": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nfractValue *= 100;\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "14": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nfractValue *= 10;\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "15": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nclear();\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "16": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nclearPrefix();\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "17": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nbreak;\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "18": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nreturn position;                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "19": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((fractValue <= 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "20": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue == 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "21": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((suffixPos >= 0)){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "22": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((position <= 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "23": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((suffixPos <= 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "24": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((position + length)){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "25": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((position + length) != suffixPos)){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "26": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((fractLen <= 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "27": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue <= 0)){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "28": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((length <= 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "29": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue != 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "30": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "31": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((fractPos - position)){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "32": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((iFieldType != SECONDS_OPTIONAL_MILLIS)){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "33": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((iFieldType != SECONDS_MILLIS)){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "34": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((-wholeValue <= 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "35": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(!wholeValue){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "36": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(wholeValue){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "37": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((fractPos - position) - 1)){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "38": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && ((position + length) != suffixPos))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "39": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(fractLen){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "40": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue <= 2)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "41": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((suffixPos >= 0) && (wholeValue <= 0))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "42": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue <= 1)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "43": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nreturn;\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "44": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\ncontinue;\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "45": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((fractLen == 1)){\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n}\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "46": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((suffixPos >= 0) && ((position + length) != suffixPos))){\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n}\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "47": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((fractLen >= 3)){\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n}\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "48": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue <= 10)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "49": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((fractLen == 1)){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "50": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue | 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "51": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((fractLen <= 0)){\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n}\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "52": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif((wholeValue & 0)){                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "53": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                    if (wholeValue <= 0) {                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "54": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nbreak;\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "55": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue > fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "56": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue == fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "57": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue < fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "58": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue != fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "59": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue != null))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "60": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (fractLen == fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "61": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue >= fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "62": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (fractLen > fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "63": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (fractLen < fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "64": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue == 0))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "65": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (fractLen != fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "66": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue == null))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "67": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue == fractValue))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "68": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) || (wholeValue < fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "69": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue != fractValue))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "70": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) || (wholeValue > fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
          "71": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\nif(((wholeValue <= 0) && (wholeValue <= fractLen))){\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }"
}