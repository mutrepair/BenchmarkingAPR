{
          "0": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / j);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "1": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / k);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "2": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (j / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "3": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight - grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "4": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "5": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (k / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "6": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "7": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / weight[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "8": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / ak);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "9": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight * grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "10": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (ak / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "11": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (residual / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "12": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight[k] / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "13": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / weight[l]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "14": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / wr);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "15": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nfinal double wgk = (weight / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "16": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (grad[k] / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "17": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / grad[l]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "18": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (wr / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "19": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight[l] / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "20": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / grad[i]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "21": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / weight[j]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "22": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / grad[j]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "23": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight >> grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "24": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nlong wgk = (weight / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "25": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / weight);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "26": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / weight[i]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "27": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight % grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "28": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / previous);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "29": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight[j] / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "30": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nfinal double[] wgk = (weight / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "31": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight << grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "32": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / i);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "33": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / nC);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "34": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nif(converged){\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n}\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "35": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nb[j] += (wr * grad[j]);\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "36": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nif((ak != null)){\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n}\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "37": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (previous / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "38": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nconverged = checker.converged(getIterations(), previous, current);\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "39": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "40": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nak[l] += (wgk * grad[l]);\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "41": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nif((j != null)){\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n}\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "42": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nif((k != null)){\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n}\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "43": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight >>> grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "44": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / grad[weight]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "45": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nbreak;\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "46": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight <= grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "47": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight + grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "48": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble[] wgk = (weight / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "49": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble[] wgk = (weight / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "50": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nreturn current;                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "51": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight >= grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "52": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / grad[k]) * weight);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "53": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nfinal double[] grad = weightedJacobian.getRow(i);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "54": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nfor(int k = 0;(k < nC);++k) {                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "55": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nfinal double wr = (weight * residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "56": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nfinal double weight = residualsWeights[i];\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "57": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\nreturn;\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "58": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / grad[k]) * residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "59": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / grad[k]) * grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "60": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight * (weight / grad[k]));\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "61": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight * weight);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "62": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / grad[k]) / weight);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "63": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ncontinue;\n                    double wgk = weight / grad[k];                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "64": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight * residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "65": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / grad[k]) / residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "66": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight / (weight / grad[k]));\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "67": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight - residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "68": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / grad[k]) * weight[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "69": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = (weight * weight[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "70": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * residual) * grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "71": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / residual) * grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "72": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * residual) / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "73": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * j) * grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "74": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / residual) / grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "75": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / j) * grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "76": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * weight) * grad[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "77": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * grad[k]) * residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "78": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * residual) * residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "79": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight / residual) * residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "80": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * residual) / residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "81": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * residual) * weight);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "82": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * j) * residual);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
          "83": "    public PointVectorValuePair doOptimize() {\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        for (boolean converged = false; !converged;) {\n            incrementIterationCount();\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\ndouble wgk = ((weight * residual) * weight[k]);\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(getIterations(), previous, current);\n                if (converged) {\n                    return current;\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }"
}