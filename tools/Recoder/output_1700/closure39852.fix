{
          "0": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nbreak;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "1": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nreturn;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "2": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nemitAllWarnings();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "3": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nemitAllTypeWarnings();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "4": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nemitUnknownTweakErrors();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "5": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ncontinue;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "6": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ncompiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "7": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ncompiler.report(t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "8": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ntweakInfo = new TweakInfo(tweakId);\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "9": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ncompiler.report(t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "10": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nsuper.visit();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "11": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ntweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n, tweakDefaultValueNode);\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "12": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nallTweaks.put(tweakId, tweakInfo);\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "13": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nbreak;\nreturn;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "14": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\n            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "15": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ntweakInfo.emitAllWarnings();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "16": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ntweakInfo.emitAllTypeWarnings();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "17": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ntweakInfo.emitUnknownTweakErrors();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "18": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nthis.emitAllWarnings();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "19": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nthis.emitAllTypeWarnings();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "20": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nthis.emitUnknownTweakErrors();\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "21": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nbreak;\nbreak;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "22": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "23": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nallTweaks.put(false);\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "24": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nallTweaks.put(true);\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "25": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nbreak;\ncontinue;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "26": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nif(true){            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "27": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\n(true)          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "28": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ntweakInfo = new TweakInfo(tweakId);\nbreak;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "29": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\n(false)          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "30": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nif(false){            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "31": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ntweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n, tweakDefaultValueNode);\nbreak;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "32": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nif(!t.inGlobalScope()){\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n}\n      }\n    }",
          "33": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nif((tweakInfo == null)){\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n}\n      }\n    }",
          "34": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nbreak;\ncompiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "35": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nreturn;\nreturn;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "36": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ncompiler.report(t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\nbreak;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "37": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nif(tweakInfo.isRegistered()){\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n}\n      }\n    }",
          "38": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nbreak;\ncompiler.report(t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "39": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ncompiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\nbreak;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "40": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ncompiler.report(t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\nbreak;\n          if (!false) {            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "41": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\nbreak;\n            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }",
          "42": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!n.isCall()) {\n        return;\n      }\n\n      String callName = n.getFirstChild().getQualifiedName();\n      TweakFunction tweakFunc = TWEAK_FUNCTIONS_MAP.get(callName);\n      if (tweakFunc == null) {\n        return;\n      }\n\n      if (tweakFunc == TweakFunction.GET_COMPILER_OVERRIDES) {\n        getOverridesCalls.add(\n            new TweakFunctionCall(t.getSourceName(), tweakFunc, n));\n        return;\n      }\n\n      // Ensure the first parameter (the tweak ID) is a string literal.\n      Node tweakIdNode = n.getFirstChild().getNext();\n      if (!tweakIdNode.isString()) {\n        compiler.report(t.makeError(tweakIdNode, NON_LITERAL_TWEAK_ID_ERROR));\n        return;\n      }\n      String tweakId = tweakIdNode.getString();\n\n      // Make sure there is a TweakInfo structure for it.\n      TweakInfo tweakInfo = allTweaks.get(tweakId);\n      if (tweakInfo == null) {\n        tweakInfo = new TweakInfo(tweakId);\n        allTweaks.put(tweakId, tweakInfo);\n      }\n\n      switch (tweakFunc) {\n        case REGISTER_BOOLEAN:\n        case REGISTER_NUMBER:\n        case REGISTER_STRING:\n          // Ensure the ID contains only valid characters.\ncontinue;\n            compiler.report(t.makeError(tweakIdNode, INVALID_TWEAK_ID_ERROR));\n          }\n\n          // Ensure tweaks are registered in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n\n          // Ensure tweaks are registered only once.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_MULTIPLY_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          Node tweakDefaultValueNode = tweakIdNode.getNext().getNext();\n          tweakInfo.addRegisterCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case OVERRIDE_DEFAULT_VALUE:\n          // Ensure tweaks overrides occur in the global scope.\n          if (!t.inGlobalScope()) {\n            compiler.report(\n                t.makeError(n, NON_GLOBAL_TWEAK_INIT_ERROR, tweakId));\n            break;\n          }\n          // Ensure tweak overrides occur before the tweak is registered.\n          if (tweakInfo.isRegistered()) {\n            compiler.report(\n                t.makeError(n, TWEAK_OVERRIDE_AFTER_REGISTERED_ERROR, tweakId));\n            break;\n          }\n\n          tweakDefaultValueNode = tweakIdNode.getNext();\n          tweakInfo.addOverrideDefaultValueCall(t.getSourceName(), tweakFunc, n,\n              tweakDefaultValueNode);\n          break;\n        case GET_BOOLEAN:\n        case GET_NUMBER:\n        case GET_STRING:\n          tweakInfo.addGetterCall(t.getSourceName(), tweakFunc, n);\n      }\n    }"
}