{
          "0": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((maybeBaseType != null)){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "1": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "2": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs != !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "3": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(mayBeFromExterns()){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "4": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(mayHaveNonEmptyReturns()){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "5": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(mayHaveSingleThrow()){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "6": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((returnTypeInferred == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "7": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((isConstructor == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "8": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesDicts == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "9": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((isInterface == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "10": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((hasNonEmptyReturns == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "11": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == returnTypeInferred)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "12": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "13": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == makesStructs)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "14": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == makesDicts)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "15": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == isInterface)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "16": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == hasNonEmptyReturns)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "17": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(isConstructor){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "18": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(!isConstructor){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "19": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs > !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "20": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs >= !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "21": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(!mayBeFromExterns()){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "22": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(!mayHaveNonEmptyReturns()){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "23": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(!mayHaveSingleThrow()){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "24": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == !isConstructor)){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "25": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(((makesStructs == !isConstructor) || maybeBaseType.setValidator(new ExtendedTypeValidator()))){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "26": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(makesStructs){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "27": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs < !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "28": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(((makesStructs == !isConstructor) && maybeBaseType.setValidator(new ExtendedTypeValidator()))){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "29": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(!makesStructs){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "30": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == !returnTypeInferred)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "31": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == !makesStructs)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "32": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == !makesDicts)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "33": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == !isInterface)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "34": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == !hasNonEmptyReturns)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "35": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs && !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "36": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs <= !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "37": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((!returnTypeInferred == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "38": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((!isConstructor == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "39": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((!makesStructs == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "40": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((!makesDicts == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "41": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((!isInterface == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "42": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((!hasNonEmptyReturns == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "43": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((fnName == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "44": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs == fnName)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "45": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((CONSTRUCTOR_REQUIRED == !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "46": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nrecordNonEmptyReturn();\n      if (makesStructs == !isConstructor) {        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "47": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(!fnName){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "48": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(fnName){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "49": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(((makesStructs == !isConstructor) || !mayBeFromExterns())){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "50": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(((makesStructs == !isConstructor) || !mayHaveNonEmptyReturns())){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "51": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(((makesStructs == !isConstructor) || !mayHaveSingleThrow())){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "52": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nreportWarning(CONSTRUCTOR_REQUIRED, \"null\", fnName);\n      if (makesStructs == !isConstructor) {        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "53": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesStructs || !isConstructor)){        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "54": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(info.hasBaseType()){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "55": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif((makesDicts && !isConstructor)){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "56": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nreturn;\n      if (makesStructs == !isConstructor) {        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "57": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nbaseType = (ObjectType)maybeBaseType;\n      if (makesStructs == !isConstructor) {        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "58": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nreportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n      if (makesStructs == !isConstructor) {        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "59": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nbreak;\n      if (makesStructs == !isConstructor) {        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "60": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\n      if (makesStructs == !isConstructor) {        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
          "61": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      makesStructs = info.makesStructs();\n      makesDicts = info.makesDicts();\n      isInterface = info.isInterface();\n\nif(((makesStructs == !isConstructor) || (isConstructor == isConstructor))){\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@struct\", fnName);\n      } else if (makesDicts && !isConstructor) {\n        reportWarning(CONSTRUCTOR_REQUIRED, \"@dict\", fnName);\n      }\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // Implemented interfaces (for constructors only).\n      if (info.getImplementedInterfaceCount() > 0) {\n        if (isConstructor) {\n          implementedInterfaces = Lists.newArrayList();\n          for (JSTypeExpression t : info.getImplementedInterfaces()) {\n            JSType maybeInterType = t.evaluate(scope, typeRegistry);\n            if (maybeInterType != null &&\n                maybeInterType.setValidator(new ImplementedTypeValidator())) {\n              implementedInterfaces.add((ObjectType) maybeInterType);\n            }\n          }\n        } else if (isInterface) {\n          reportWarning(\n              TypeCheck.CONFLICTING_IMPLEMENTED_TYPE, fnName);\n        } else {\n          reportWarning(CONSTRUCTOR_REQUIRED, \"@implements\", fnName);\n        }\n      }\n\n      // extended interfaces (for interfaces only)\n      // We've already emitted a warning if this is not an interface.\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }"
}