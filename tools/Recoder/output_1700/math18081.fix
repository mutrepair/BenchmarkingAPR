{
          "0": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif(false){                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "1": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "2": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif(true){                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "3": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nreturn;\n            } else if (true) {                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "4": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\ntargetY = yA.divide(16).negate();\n            } else if (true) {                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "5": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\ntargetY = zero;\n            } else if (true) {                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "6": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\ntargetY = yB.divide(16).negate();\n            } else if (true) {                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "7": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif(zero){\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "8": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif(agingA){\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "9": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif(-false){                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "10": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif((agingA >= MAXIMAL_AGING)){\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "11": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nbreak;\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "12": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif(16){                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "13": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif(!zero){\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "14": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif(!agingA){\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "15": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif((targetY != null)){\n            } else if (true) {                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n}\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "16": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nif((agingA >= MAXIMAL_AGING)){\n            } else if (true) {                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n}\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "17": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\nbreak;\n            } else if (true) {                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "18": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\ntargetY = yA.divide(16).negate();\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "19": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\ncontinue;\n            } else if (true) {                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }",
          "20": "    public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                     final Dfp min, final Dfp max, final Dfp startValue,\n                     final AllowedSolution allowedSolution)\n        throws NullArgumentException, NoBracketingException {\n\n        // Checks.\n        MathUtils.checkNotNull(f);\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        Dfp zero = startValue.getZero();\n        Dfp nan  = zero.newInstance((byte) 1, Dfp.QNAN);\n\n        // prepare arrays with the first points\n        final Dfp[] x = new Dfp[maximalOrder + 1];\n        final Dfp[] y = new Dfp[maximalOrder + 1];\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        // evaluate initial guess\n        evaluations.incrementCount();\n        y[1] = f.value(x[1]);\n        if (y[1].isZero()) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        evaluations.incrementCount();\n        y[0] = f.value(x[0]);\n        if (y[0].isZero()) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0].multiply(y[1]).negativeOrNull()) {\n\n            // reduce interval if it brackets the root\n            nbPoints        = 2;\n            signChangeIndex = 1;\n\n        } else {\n\n            // evaluate second endpoint\n            evaluations.incrementCount();\n            y[2] = f.value(x[2]);\n            if (y[2].isZero()) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1].multiply(y[2]).negativeOrNull()) {\n                // use all computed point as a start sampling array for solving\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0].toDouble(), x[2].toDouble(),\n                                                y[0].toDouble(), y[2].toDouble());\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final Dfp[] tmpX = new Dfp[x.length];\n\n        // current tightest bracketing of the root\n        Dfp xA    = x[signChangeIndex - 1];\n        Dfp yA    = y[signChangeIndex - 1];\n        Dfp absXA = xA.abs();\n        Dfp absYA = yA.abs();\n        int agingA   = 0;\n        Dfp xB    = x[signChangeIndex];\n        Dfp yB    = y[signChangeIndex];\n        Dfp absXB = xB.abs();\n        Dfp absYB = yB.abs();\n        int agingB   = 0;\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            Dfp maxX = absXA.lessThan(absXB) ? absXB : absXA;\n            Dfp maxY = absYA.lessThan(absYB) ? absYB : absYA;\n            final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n            if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                maxY.lessThan(functionValueAccuracy)) {\n                switch (allowedSolution) {\n                case ANY_SIDE :\n                    return absYA.lessThan(absYB) ? xA : xB;\n                case LEFT_SIDE :\n                    return xA;\n                case RIGHT_SIDE :\n                    return xB;\n                case BELOW_SIDE :\n                    return yA.lessThan(zero) ? xA : xB;\n                case ABOVE_SIDE :\n                    return yA.lessThan(zero) ? xB : xA;\n                default :\n                    // this should never happen\n                    throw new MathInternalError(null);\n                }\n            }\n\n            // target for the next evaluation point\n            Dfp targetY;\n            if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                targetY = yB.divide(16).negate();\ntargetY = zero;\n                // we keep updating the low bracket, try to compensate this\n                targetY = yA.divide(16).negate();\n            } else {\n                // bracketing is balanced, try to find the root itself\n                targetY = zero;\n            }\n\n            // make a few attempts to guess a root,\n            Dfp nextX;\n            int start = 0;\n            int end   = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targetY, tmpX, y, start, end);\n\n                if (!(nextX.greaterThan(xA) && nextX.lessThan(xB))) {\n                    // the guessed root is not strictly inside of the tightest bracketing interval\n\n                    // the guessed root is either not strictly inside the interval or it\n                    // is a NaN (which occurs when some sampling points share the same y)\n                    // we try again with a lower interpolation order\n                    if (signChangeIndex - start >= end - signChangeIndex) {\n                        // we have more points before the sign change, drop the lowest point\n                        ++start;\n                    } else {\n                        // we have more points after sign change, drop the highest point\n                        --end;\n                    }\n\n                    // we need to do one more attempt\n                    nextX = nan;\n\n                }\n\n            } while (nextX.isNaN() && (end - start > 1));\n\n            if (nextX.isNaN()) {\n                // fall back to bisection\n                nextX = xA.add(xB.subtract(xA).divide(2));\n                start = signChangeIndex - 1;\n                end   = signChangeIndex;\n            }\n\n            // evaluate the function at the guessed root\n            evaluations.incrementCount();\n            final Dfp nextY = f.value(nextX);\n            if (nextY.isZero()) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndex -= start;\n\n            } else  if (nbPoints == x.length) {\n\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n\n                // keep the tightest bracketing interval as centered as possible\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                }\n\n            }\n\n            // insert the last computed point\n            //(by construction, we know it lies inside the tightest bracketing interval)\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = nextX;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY.multiply(yA).negativeOrNull()) {\n                // the sign change occurs before the inserted point\n                xB = nextX;\n                yB = nextY;\n                absYB = yB.abs();\n                ++agingA;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = nextX;\n                yA = nextY;\n                absYA = yA.abs();\n                agingA = 0;\n                ++agingB;\n\n                // update the sign change index\n                signChangeIndex++;\n\n            }\n\n        }\n\n    }"
}