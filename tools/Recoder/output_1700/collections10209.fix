{
          "0": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k <= start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "1": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k < start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "2": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k - start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "3": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "4": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k > start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "5": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k + start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "6": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k >= start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "7": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vDown, ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "8": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "9": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(start, ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "10": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end, ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "11": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(diag, ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "12": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nvDown[i] = ++x;\n                        return buildSnake(vUp[i-delta], k % start1 - start2, end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "13": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\n++y;\n                        return buildSnake(vUp[i-delta], k % start1 - start2, end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "14": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nif((vUp[(i - delta)] <= vDown[i])){\n}\n                        return buildSnake(vUp[i-delta], k % start1 - start2, end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "15": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % vUp[(i - delta)]) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "16": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nvDown[i] = vDown[(i + 1)];\n                        return buildSnake(vUp[i-delta], k % start1 - start2, end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "17": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nvDown[i] = (vDown[(i - 1)] + 1);\n                        return buildSnake(vUp[i-delta], k % start1 - start2, end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "18": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % vUp[i]) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "19": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[i], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "20": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nbreak;\n                        return buildSnake(vUp[i-delta], k % start1 - start2, end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "21": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k == start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "22": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % start1) - vUp[(i - delta)]), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "23": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % vUp) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "24": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2[(i - delta)], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "25": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vDown[(i - delta)], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "26": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(start[(i - delta)], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "27": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end[(i - delta)], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "28": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(diag[(i - delta)], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "29": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % end2[(i - delta)]) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "30": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn equate(vUp[(i - delta)], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "31": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k / start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "32": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1[(i - delta)], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "33": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % end1[(i - delta)]) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "34": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake();                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "35": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2[i], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "36": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(x, ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "37": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(i, ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "38": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k & start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "39": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % start1) - vUp[i]), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "40": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1, ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "41": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "42": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % start1[(i - delta)]) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "43": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % end1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "44": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % end2) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "45": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn getMiddleSnake(vUp[(i - delta)], ((k % start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "46": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % end2[i]) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "47": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % start1) - start2), end1, vUp[(i - delta)]);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "48": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn;\n                        return buildSnake(vUp[i-delta], k % start1 - start2, end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "49": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(x);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "50": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k | start1) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "51": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % start1) - vUp), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "52": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], ((k % i) - start2), end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "53": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\ncontinue;\n                        return buildSnake(vUp[i-delta], k % start1 - start2, end1, end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "54": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "55": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, vUp, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "56": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, end2, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "57": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, end2, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "58": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp[(i - delta)], ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "59": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1, vUp, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "60": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, vUp[(i - delta)], ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "61": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, end1, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "62": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, end1, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "63": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1, end2, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "64": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1, vUp[(i - delta)], ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "65": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1, end1, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "66": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp[(i - delta)], vUp, ((k % start1) - start2));                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "67": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, vUp[(i - delta)], vUp, ((k % start1) - start2));                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "68": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], vUp, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "69": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1, vUp[(i - delta)], vUp, ((k % start1) - start2));                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "70": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], vUp[(i - delta)], ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "71": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, vUp[(i - delta)], ((k % start1) - start2), end2);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "72": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp[(i - delta)], ((k % start1) - start2), vUp[(i - delta)]);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "73": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, vUp[(i - delta)], ((k % start1) - start2), vUp[(i - delta)]);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "74": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1, vUp[(i - delta)], ((k % start1) - start2), vUp[(i - delta)]);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "75": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], vUp[(i - delta)], vUp, ((k % start1) - start2));                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "76": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp[(i - delta)], vUp[(i - delta)], ((k % start1) - start2));                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "77": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp, ((k % start1) - start2), ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "78": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, vUp[(i - delta)], vUp[(i - delta)], ((k % start1) - start2));                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "79": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1, vUp[(i - delta)], vUp[(i - delta)], ((k % start1) - start2));                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "80": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp[(i - delta)], ((k % start1) - start2), ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "81": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, vUp[(i - delta)], ((k % start1) - start2), ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "82": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp[(i - delta)], vUp[(i - delta)], vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "83": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], vUp[(i - delta)], vUp[(i - delta)], ((k % start1) - start2));                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "84": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, vUp[(i - delta)], vUp[(i - delta)], vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "85": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end1, vUp[(i - delta)], vUp[(i - delta)], vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "86": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], vUp[(i - delta)], vUp, vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "87": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp[(i - delta)], vUp, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "88": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp[(i - delta)], vUp[(i - delta)], vUp[(i - delta)], vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "89": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(vUp, vUp[(i - delta)], vUp[(i - delta)], vUp[(i - delta)]);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }",
          "90": "    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n        // Myers Algorithm\n        // Initialisations\n        final int m = end1 - start1;\n        final int n = end2 - start2;\n        if (m == 0 || n == 0) {\n            return null;\n        }\n\n        final int delta  = m - n;\n        final int sum    = n + m;\n        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n        vDown[1+offset] = start1;\n        vUp[1+offset]   = end1 + 1;\n\n        for (int d = 0; d <= offset ; ++d) {\n            // Down\n            for (int k = -d; k <= d; k += 2) {\n                // First step\n\n                final int i = k + offset;\n                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n                    vDown[i] = vDown[i+1];\n                } else {\n                    vDown[i] = vDown[i-1] + 1;\n                }\n\n                int x = vDown[i];\n                int y = x - start1 + start2 - k;\n\n                while (x < end1 && y < end2 && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vDown[i] = ++x;\n                    ++y;\n                }\n                // Second step\n                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n                    if (vUp[i-delta] <= vDown[i]) {\nreturn buildSnake(end2, vUp[(i - delta)], vUp, ((k % start1) - start2), vUp);                    }\n                }\n            }\n\n            // Up\n            for (int k = delta - d; k <= delta + d; k += 2) {\n                // First step\n                final int i = k + offset - delta;\n                if (k == delta - d\n                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n                    vUp[i] = vUp[i+1] - 1;\n                } else {\n                    vUp[i] = vUp[i-1];\n                }\n\n                int x = vUp[i] - 1;\n                int y = x - start1 + start2 - k;\n                while (x >= start1 && y >= start2\n                        && equator.equate(sequence1.get(x), sequence2.get(y))) {\n                    vUp[i] = x--;\n                    y--;\n                }\n                // Second step\n                if (delta % 2 == 0 && -d <= k && k <= d ) {\n                    if (vUp[i] <= vDown[i + delta]) {\n                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n                    }\n                }\n            }\n        }\n\n        // this should not happen\n        throw new RuntimeException(\"Internal Error\");\n    }"
}