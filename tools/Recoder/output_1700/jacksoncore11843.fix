{
          "0": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c > \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "1": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "2": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c <= \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "3": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((c == \".\") || (c >= \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "4": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c == \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "5": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c < \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "6": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c != \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "7": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c >= \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "8": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c > \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "9": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c <= \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "10": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) && (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "11": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c != \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "12": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c && \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "13": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c < \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "14": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "15": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c || \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "16": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c instanceof \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "17": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((c == \".\")){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "18": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((c >= \".\")){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "19": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "20": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c & \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "21": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((c == \".\") || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "22": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((c == \".\") || (c >= \".\")) || (c == \".\")) && (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "23": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) && (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "24": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "25": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c && \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "26": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "27": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c >= \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "28": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (((c == \".\") || (c >= \".\")) || (c == \".\")))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "29": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c >>> \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "30": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c instanceof \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "31": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (c & \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "32": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((c == \".\") && (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "33": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c >= \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "34": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || ((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c == \".\")))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "35": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c == \".\")) && (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "36": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((outPtr >= outBuf.length)){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "37": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((((c == \".\") || (c >= \".\")) || (c == \".\")) && (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "38": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((c == \".\") || (c >= \".\")) || (c >= \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "39": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((_inputPtr >= end)){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "40": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || ((((c == \".\") || (c >= \".\")) || (c == \".\")) && (c == \".\")))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "41": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || ((c == \".\") || (c == \".\")))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "42": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((c == \".\") || (c >= \".\")) && (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "43": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((c < INT_0) || (c > INT_9))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "44": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) && (((c == \".\") || (c >= \".\")) || (c == \".\")))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "45": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (_inputPtr == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "46": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || ((c == \".\") || (c >= \".\")))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "47": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (outPtr >= \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "48": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (intLen >= \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "49": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (negative >= \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "50": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (outBuf >= \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "51": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "52": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) && (c >= \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "53": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\noutPtr = 0;\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "54": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c >> \".\") || (c >= \".\")) || (c == \".\"))){            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "55": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\noutPtr = 0;\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "56": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((c == \".\") || (c == \".\")) || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "57": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n--_inputPtr;\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "58": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n_textBuffer.setCurrentLength(outPtr);\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "59": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\noutBuf[outPtr++] = (char)c;\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "60": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\noutBuf = _textBuffer.finishCurrentSegment();\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "61": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\noutBuf = _textBuffer.finishCurrentSegment();\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "62": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nc = ((int)_inputBuffer[_inputPtr++] & 0xFF);\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "63": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n++intLen;\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "64": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((c == \".\") || (c >= \".\")) || (((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\")))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "65": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n_textBuffer.setCurrentLength(outPtr);\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "66": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "67": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif((((((((c == \".\") || (c >= \".\")) || (c == \".\")) && (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "68": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nbreak;\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "69": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nreturn;\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "70": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "71": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((((((c == \".\") || (c >= \".\")) || (c == \".\")) || (c == \".\")) && (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "72": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\nif(((((((((c == \".\") || (c >= \".\")) || (c == \".\")) && (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\")) || (c == \".\"))){\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "73": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "74": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\ncontinue;\n        if (c == '.' || c >= 'e' || c == 'E') {            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }"
}