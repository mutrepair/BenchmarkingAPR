{
          "0": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nZipEncodingHelper.growBuffer(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "1": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, out);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "2": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (res.length() * 0));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "3": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.getName() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "4": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "5": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.remaining() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "6": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (res.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "7": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nZipEncodingHelper.appendSurrogate(out, cb.get());\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "8": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = out;\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "9": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "10": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.allocate(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "11": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, 0);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "12": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.onMalformedInput(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "13": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer((out.position() + (res.length() * 0)), out);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "14": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, cb);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "15": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (cb.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "16": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.onUnmappableCharacter(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "17": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nenc.flush(out);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "18": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (enc.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "19": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer((out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "20": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(cb, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "21": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.isMalformed() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "22": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.isUnmappable() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "23": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.encode(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "24": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (cb.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "25": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, res);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "26": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (enc.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "27": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (out.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "28": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nif((out != null)){\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n}\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "29": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(res, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "30": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, );\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "31": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (res.length() + 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "32": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, out.position());\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "33": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.appendSurrogate(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "34": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (res.length() - 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "35": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.length() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "36": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.encode() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "37": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, enc);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "38": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() - (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "39": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nenc.flush(out);\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "40": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = (out.position() + (res.length() * 0));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "41": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(i, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "42": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.get() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "43": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, name);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "44": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (name.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "45": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "46": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(name);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "47": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nZipEncodingHelper.appendSurrogate(out, cb.get());\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "48": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nenc.onMalformedInput(CodingErrorAction.REPORT);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "49": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.wrap(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "50": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = out.position();\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "51": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.debug(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "52": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = enc.growBuffer(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "53": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, 0);\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "54": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = out.growBuffer();\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "55": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "56": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "57": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout.limit(out.position());\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "58": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.add(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "59": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, res.length());\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "60": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nif(((res.length() * 6) > out.remaining())){\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n}\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "61": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (name.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "62": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.limit(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "63": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout.rewind();\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "64": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nif(res.isUnderflow()){\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n}\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "65": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = enc.encode(cb, out, true);\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "66": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nif(res.isOverflow()){\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n}\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "67": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, ((out.position() + (res.length() * 0)) + 0));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "68": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (ZipEncodingHelper.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "69": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "70": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout.limit(out.position());\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "71": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(enc, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "72": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nenc.onMalformedInput(CodingErrorAction.REPORT);\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "73": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nreturn out;                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "74": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (out.position() + (res.length() <= 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "75": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nenc.onUnmappableCharacter(CodingErrorAction.REPORT);\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "76": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout.rewind();\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "77": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nif((res.length() * 6)){\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n}\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "78": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nbreak;\n                    out = ZipEncodingHelper.growBuffer(out, out.position()\n                                                       + res.length() * 0);                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "79": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(name, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "80": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = ZipEncodingHelper.growBuffer(out, (ZipEncodingHelper.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
          "81": "    public ByteBuffer encode(String name) {\n        CharsetEncoder enc = this.charset.newEncoder();\n\n        enc.onMalformedInput(CodingErrorAction.REPORT);\n        enc.onUnmappableCharacter(CodingErrorAction.REPORT);\n\n        CharBuffer cb = CharBuffer.wrap(name);\n        ByteBuffer out = ByteBuffer.allocate(name.length()\n                                             + (name.length() + 1) / 2);\n\n        while (cb.remaining() > 0) {\n            CoderResult res = enc.encode(cb, out,true);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n                if (res.length() * 6 > out.remaining()) {\nout = name.growBuffer(out, (out.position() + (res.length() * 0)));\n                }\n\n                for (int i=0; i<res.length(); ++i) {\n                    ZipEncodingHelper.appendSurrogate(out,cb.get());\n                }\n\n            } else if (res.isOverflow()) {\n\n                out = ZipEncodingHelper.growBuffer(out, 0);\n\n            } else if (res.isUnderflow()) {\n\n                enc.flush(out);\n                break;\n\n            }\n        }\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }"
}