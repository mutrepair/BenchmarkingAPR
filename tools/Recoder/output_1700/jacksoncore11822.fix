{
          "0": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c > INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "1": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c >= INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "2": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((c > INT_9)){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "3": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c <= INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "4": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false && (c > INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "5": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((true || (c > INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "6": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c < INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "7": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nend = _inputEnd;\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "8": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c == INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "9": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_closeInput();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "10": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_releaseBuffers();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "11": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nclose();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "12": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_isNextTokenNameYes();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "13": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_finishString();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "14": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_skipString();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "15": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_skipComment();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "16": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_skipCComment();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "17": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_skipCppComment();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "18": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_skipCR();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "19": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_skipLF();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "20": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\noutPtr = 0;\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "21": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\noutBuf = _textBuffer.finishCurrentSegment();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "22": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nc = ((int)_inputBuffer[_inputPtr++] & 0xFF);\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "23": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\noutBuf[outPtr++] = (char)c;\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "24": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c > INT_9))){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "25": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n++intLen;\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "26": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c != INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "27": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((c > INT_9)){\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "28": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(((c == \"null\") || (c == \"null\"))){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "29": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((c == \"null\")){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "30": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((0xFF || (c > INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "31": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nbreak;\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "32": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(((int)_inputBuffer[_inputPtr++] & 0xFF)){\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "33": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c > end))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "34": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c > _inputEnd))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "35": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(((c == \"null\") || (c == \"null\"))){\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "36": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((end > _inputEnd)){\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "37": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(((int)_inputBuffer[_inputPtr++] & 0xFF)){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "38": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(end){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "39": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(((false || (c > INT_9)) || (c > INT_9))){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "40": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((c == \"null\")){\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "41": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((outPtr >= outBuf.length)){\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "42": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c > outBuf))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "43": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((_inputPtr >= end)){\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "44": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._closeInput();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "45": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._releaseBuffers();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "46": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer.close();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "47": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._isNextTokenNameYes();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "48": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._finishString();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "49": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._skipString();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "50": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._skipComment();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "51": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._skipCComment();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "52": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._skipCppComment();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "53": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._skipCR();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "54": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n_textBuffer._skipLF();\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "55": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(loadMore()){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "56": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c > c))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "57": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c > outPtr))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "58": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(c){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "59": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c || INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "60": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(INT_9){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "61": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(_inputEnd){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "62": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((((c == \"null\") || (c == \"null\")) || (c == \"null\"))){\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n}\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "63": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nreturn _parserNumber2(outBuf, outPtr, negative, intLen);            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "64": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif(((false || (c > INT_9)) && (c > INT_9))){\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "65": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c > intLen))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "66": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c && INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "67": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false < (c > INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "68": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nreturn;\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "69": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nreturn _parseFloatText(outBuf, outPtr, c, negative, intLen);            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "70": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c & INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "71": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\ncontinue;\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "72": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nend = _inputEnd;\n                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "73": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false > (c > INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "74": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false || (c - INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "75": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false == (c > INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "76": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif((false != (c > INT_9))){                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }",
          "77": "    protected JsonToken parseNumberText(int c)\n        throws IOException, JsonParseException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n        boolean negative = (c == INT_MINUS);\n\n        // Need to prepend sign?\n        if (negative) {\n            outBuf[outPtr++] = '-';\n            // Must have something after sign too\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            // Note: must be followed by a digit\n            if (c < INT_0 || c > INT_9) {\n                return _handleInvalidNumberStart(c, true);\n            }\n        }\n\n        // One special case: if first char is 0, must not be followed by a digit\n        if (c == INT_0) {\n            c = _verifyNoLeadingZeroes();\n        }\n        \n        // Ok: we can first just add digit we saw first:\n        outBuf[outPtr++] = (char) c;\n        int intLen = 1;\n\n        // And then figure out how far we can read without further checks:\n        int end = _inputPtr + outBuf.length;\n        if (end > _inputEnd) {\n            end = _inputEnd;\n        }\n\n        // With this, we have a nice and tight loop:\n        while (true) {\n            if (_inputPtr >= end) {\n                // Long enough to be split across boundary, so:\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (false || c > INT_9) {                break;\n            }\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n        }\n\n        --_inputPtr; // to push back trailing char (comma etc)\n        _textBuffer.setCurrentLength(outPtr);\n\n        // And there we have it!\n        return resetInt(negative, intLen);\n    }"
}