{
          "0": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "1": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramAnns.length + 0)){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "2": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount != (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "3": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length == 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "4": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount >= (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "5": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length != 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "6": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((\"null\" + ctor.getDeclaringClass().getName())){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "7": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((((\"null\" + ctor.getDeclaringClass().getName()) + \"null\") + paramCount)){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "8": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((((((\"null\" + ctor.getDeclaringClass().getName()) + \"null\") + paramCount) + \"null\") + paramAnns.length)){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "9": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(((((\"null\" + ctor.getDeclaringClass().getName()) + \"null\") + paramCount) + \"null\")){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "10": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount <= (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "11": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(((\"null\" + ctor.getDeclaringClass().getName()) + \"null\")){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "12": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount > (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "13": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length + 2))){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "14": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "15": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount < (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "16": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramAnns.length + 2)){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "17": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nreturn new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations);                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "18": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount && (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "19": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((old.length + 2)){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "20": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((old == (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "21": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nresolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "22": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((dc == (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "23": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nparamAnns = new Annotation[[]];\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "24": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(( == (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "25": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramAnns == (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "26": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nSystem.arraycopy(old, 0, paramAnns, 1, old.length);\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "27": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nSystem.arraycopy(old, 0, paramAnns, 2, old.length);\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "28": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nparamAnns = new Annotation[[]];\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "29": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length >= 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "30": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(hasAnnotations()){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "31": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount || (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "32": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(ctor.hasAnnotations()){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "33": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "34": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(((paramCount == (paramAnns.length + 0)) && (paramCount == (paramAnns.length + 2)))){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "35": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nreturn null;                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "36": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nresolveClassAnnotations();\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "37": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nresolveCreators();\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "38": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nresolveMemberMethods();\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "39": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nresolveFields();\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "40": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length > 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "41": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (ctor + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "42": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (old + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "43": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(dc.isMemberClass()){\ncontinue;\n}\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "44": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount + (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "45": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramCount + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "46": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length <= 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "47": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (old.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "48": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == ( + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "49": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nbreak;\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "50": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(((paramCount == (paramAnns.length + 0)) && ctor.hasAnnotations())){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "51": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length + 1))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "52": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((resolvedAnnotations == null)){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "53": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount - (paramAnns.length + 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "54": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nreturn;\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "55": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length - 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "56": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif((paramCount == (paramAnns.length < 0))){                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "57": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nresolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "58": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\ncontinue;\n                if (paramCount == (paramAnns.length + 0)) {                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "59": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(((paramCount == (paramAnns.length + 0)) && (paramAnns.length == paramAnns.length))){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "60": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\n            if (dc.isEnum() && (paramCount == paramAnns.length + 2)) {\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\nif(((paramCount == (paramAnns.length + 0)) && (paramAnns.length != paramAnns.length))){\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }"
}