{
          "0": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "1": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\ncompose(operand, operandOffset, function, result, resultOffset);\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "2": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(true){                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "3": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nfunction[n] = v;\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "4": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nv = ((v * t2) + p[k]);\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "5": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nv *= t;\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "6": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\np[0] = p[1];\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "7": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nreturn;\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "8": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\np[(n + 1)] = (n * p[n]);\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "9": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nbreak;\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "10": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\np[(k - 2)] = (((k - 1) * p[(k - 1)]) + ((k - 3) * p[(k - 3)]));\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "11": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\np[1] = 1;\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "12": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(p){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "13": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(t2){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "14": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\ncontinue;\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "15": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(3){                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "16": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(((k - 1) * p[(k - 1)])){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "17": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(((k - 3) * p[(k - 3)])){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "18": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nbreak;\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "19": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(-true){                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "20": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((n & 0x1)){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "21": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nfor(int k = (n + 1);(k >= 0);k -= 2) {                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "22": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(result){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "23": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(((k - 1) * p[(k - 1)])){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "24": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(((k - 3) * p[(k - 3)])){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "25": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((k - 3)){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "26": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(function){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "27": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(v){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "28": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((p != null)){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "29": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(0x1){                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "30": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(!p){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "31": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(n){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "32": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((((k - 1) * p[(k - 1)]) + ((k - 3) * p[(k - 3)]))){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "33": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((v * t2)){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "34": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nfor(int n = 1;(n <= order);++n) {                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "35": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((k > 2)){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "36": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(((n & 0x1) == 0)){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "37": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((k - 3)){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "38": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((t2 != null)){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "39": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((k - 1)){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "40": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(((n & 0x1) == 0)){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "41": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\np[0] = false;\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "42": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((k > 2)){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "43": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(1){                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "44": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(false){                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "45": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\ncompose(operand, operandOffset, function, result, resultOffset);\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "46": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((k != null)){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "47": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\n                    } else if (false) {                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "48": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((p != null)){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "49": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nv *= t;\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "50": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(\"null\"){                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "51": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nv = ((v * t2) + p[k]);\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "52": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nfunction[n] = v;\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "53": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\np[(n + 1)] = (n * p[n]);\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "54": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\np[0] = p[1];\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "55": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif(2){                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "56": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((p == null)){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "57": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((t2 == null)){\n                    } else if (false) {                        p[0] = p[1];\n}\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "58": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\np[(k - 2)] = (((k - 1) * p[(k - 1)]) + ((k - 3) * p[(k - 3)]));\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "59": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\ncontinue;\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "60": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((p == null)){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "61": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\np[1] = 1;\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }",
          "62": "    public void tan(final double[] operand, final int operandOffset,\n                    final double[] result, final int resultOffset) {\n\n        // create the function value and derivatives\n        final double[] function = new double[1 + order];\n        final double t = FastMath.tan(operand[operandOffset]);\n        function[0] = t;\n\n        if (order > 0) {\n\n            // the nth order derivative of tan has the form:\n            // dn(tan(x)/dxn = P_n(tan(x))\n            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n            // P_0(t) = t, P_1(t) = 1 + t^2, P_2(t) = 2 t (1 + t^2) ...\n            // the general recurrence relation for P_n is:\n            // P_n(x) = (1+t^2) P_(n-1)'(t)\n            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n            final double[] p = new double[order + 2];\n            p[1] = 1;\n            final double t2 = t * t;\n            for (int n = 1; n <= order; ++n) {\n\n                // update and evaluate polynomial P_n(t)\n                double v = 0;\n                p[n + 1] = n * p[n];\n                for (int k = n + 1; k >= 0; k -= 2) {\n                    v = v * t2 + p[k];\n                    if (k > 2) {\n                        p[k - 2] = (k - 1) * p[k - 1] + (k - 3) * p[k - 3];\nif((p != t2)){\n                        p[0] = p[1];\n                    }\n                }\n                if ((n & 0x1) == 0) {\n                    v *= t;\n                }\n\n                function[n] = v;\n\n            }\n        }\n\n        // apply function composition\n        compose(operand, operandOffset, function, result, resultOffset);\n\n    }"
}