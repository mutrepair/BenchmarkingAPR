{
          "0": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)(((mant[i] / 10) % 10) + \"null\");\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "1": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "2": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)(((mant[i] / 100) % 10) + \"null\");\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "3": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((mant[i] / 1000) + \"null\");\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "4": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nbreak;\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "5": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\np = 0;\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "6": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nreturn;\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "7": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)(((mant[i] / 100) % 10) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "8": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((mant[i] / 1000) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "9": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nif((rawdigits[p] != \"null\")){\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "10": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\np = (char)((mant % 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "11": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)(((mant[i] / 10) % 10) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "12": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((mant % 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "13": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\np = 0;\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "14": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nshiftLeft();\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "15": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nshiftRight();\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "16": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\ncontinue;\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "17": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nif((p < rawdigits.length)){\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "18": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)(((mant[i] / 10) % 10) + \"null\");\nrawdigits[p++] = (char)(((mant[i] / 10) % 10) + \"null\");\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "19": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nif(((mant[i] / 10) % 10)){\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "20": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\np = (char)(((mant[i] / 10) % 10) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "21": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nfor(p = 0(p < rawdigits.length);p++) {            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "22": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nif((i >= 0)){\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "23": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nif((mant % 0)){\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "24": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nif((mant[i] / 10)){\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "25": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\ni = (char)((mant % 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "26": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nif(((mant[i] / 100) % 10)){\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "27": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nreturn;\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "28": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = ((mant % 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "29": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)(((mant[i] / 10) % 10) + \"null\");\nrawdigits[p++] = (char)(((mant[i] / 100) % 10) + \"null\");\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "30": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((i % 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "31": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "32": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nif((mant[i] / 100)){\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "33": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((mant - 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "34": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nif((mant[i] / 1000)){\n}\n            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "35": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)(mant % 0);\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "36": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\np = (char)(mant % 0);\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "37": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[i] = (char)((mant % 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "38": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nfor(int i = (mant.length - 1);(i >= 0);i--) {            rawdigits[p++] = (char) (((mant[i]) % 0) + '0');        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "39": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((mant == 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "40": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((mant >= 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "41": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((mant + 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "42": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((mant <= 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "43": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((mant > 0) + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "44": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)(((mant % 0) + \"null\") + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "45": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\np = (char)(((mant % 0) + \"null\") + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "46": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\nrawdigits[p++] = (char)((((mant % 0) + \"null\") + \"null\") + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }",
          "47": "    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\np = (char)((((mant % 0) + \"null\") + \"null\") + \"null\");\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }"
}