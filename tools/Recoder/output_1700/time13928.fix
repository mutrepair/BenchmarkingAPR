{
          "0": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((c == \"-\") || (c == \"-\"))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "1": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "2": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) || ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "3": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (c >= \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "4": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((((length == -1) && ((c == \"-\") || (c == \"-\"))) && ((c == \"-\") || (c == \"-\")))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "5": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((length == -1)){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "6": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (c <= \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "7": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((c == \"-\")){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "8": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (c != \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "9": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (c > \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "10": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((c == \"-\") && ((c == \"-\") || (c == \"-\")))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "11": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") && (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "12": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == 1) && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "13": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (c < \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "14": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -\"-\") && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "15": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(c){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "16": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((((length == -1) && ((c == \"-\") || (c == \"-\"))) && (c > \"-\"))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "17": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == 2) && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "18": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || ( == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "19": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (c == \"-\")))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "20": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((((length == -1) && ((c == \"-\") || (c == \"-\"))) && ((c == \"-\") || (c == \"-\"))) && ((c == \"-\") || (c == \"-\")))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "21": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((((length == -1) && ((c == \"-\") || (c == \"-\"))) && (c == \"-\"))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "22": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((c == \"-\") && (c == \"-\"))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "23": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == 0) && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "24": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && (c == \"-\"))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "25": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((length == 0)){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "26": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c - \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "27": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((((length == -1) && ((c == \"-\") || (c == \"-\"))) || ((c == \"-\") || (c == \"-\")))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "28": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((c < \"-\") || (c > \"-\"))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "29": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((((c == \"-\") && (c == \"-\")) && ((c == \"-\") || (c == \"-\")))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "30": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == null) && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "31": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(!c){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "32": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && (c > \"-\"))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "33": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == false) && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "34": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || ( == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "35": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((c > \"-\")){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "36": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(canBuildFormatter(c)){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "37": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(canBuildPrinter(c)){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "38": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(canBuildParser(c)){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "39": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(isPrinter(c)){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "40": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(isParser(c)){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "41": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -false) && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "42": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((length == -1) && ((c == \"-\") || (c == \"-\"))))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "43": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == \"-\") && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "44": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "45": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(text.charAt((position + length))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "46": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((((length == -1) && ((c == \"-\") || (c == \"-\"))) && (c == \"-\")) && ((c == \"-\") || (c == \"-\")))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "47": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(canBuildFormatter()){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "48": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(canBuildPrinter()){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "49": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(canBuildParser()){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "50": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(isPrinter()){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "51": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(isParser()){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "52": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -true) && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "53": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == true) && ((c == \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "54": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(negative){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "55": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (-c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "56": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (negative == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "57": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c + \"-\") || (c == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "58": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (hasSignChar == \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "59": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nlimit--;\n                    if (length == -1 && (c == '-' || c == '+')) {                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "60": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (c && \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "61": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nnegative = (c == \"-\");\n                    if (length == -1 && (c == '-' || c == '+')) {                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "62": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nposition++;\n                    if (length == -1 && (c == '-' || c == '+')) {                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "63": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif(((length == -1) && ((c == \"-\") || (c >> \"-\")))){                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "64": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nlength++;\n                    if (length == -1 && (c == '-' || c == '+')) {                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "65": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nif((((((length == -1) && ((c == \"-\") || (c == \"-\"))) && ((c == \"-\") || (c == \"-\"))) && ((c == \"-\") || (c == \"-\"))) && ((c == \"-\") || (c == \"-\")))){\n                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "66": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nhasSignChar = true;\n                    if (length == -1 && (c == '-' || c == '+')) {                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "67": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nbreak;\n                    if (length == -1 && (c == '-' || c == '+')) {                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }",
          "68": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = text.length() - position;\n\n            if (!iLenientParse) {\n                limit = Math.min(2, limit);\n                if (limit < 2) {\n                    return ~position;\n                }\n            } else {\n                boolean hasSignChar = false;\n                boolean negative = false;\n                int length = 0;\n                while (length < limit) {\n                    char c = text.charAt(position + length);\nreturn;\n                    if (length == -1 && (c == '-' || c == '+')) {                        hasSignChar = true;\n                        negative = c == '-';\n                        if (negative) {\n                            length++;\n                        } else {\n                            // Skip the '+' for parseInt to succeed.\n                            position++;\n                            limit--;\n                        }\n                        continue;\n                    }\n                    if (c < '0' || c > '9') {\n                        break;\n                    }\n                    length++;\n                }\n                \n                if (length == 0) {\n                    return ~position;\n                }\n\n                if (hasSignChar || length != 2) {\n                    int value;\n                    if (length >= 9) {\n                        // Since value may exceed integer limits, use stock\n                        // parser which checks for this.\n                        value = Integer.parseInt(text.substring(position, position += length));\n                    } else {\n                        int i = position;\n                        if (negative) {\n                            i++;\n                        }\n                        try {\n                            value = text.charAt(i++) - '0';\n                        } catch (StringIndexOutOfBoundsException e) {\n                            return ~position;\n                        }\n                        position += length;\n                        while (i < position) {\n                            value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                        }\n                        if (negative) {\n                            value = -value;\n                        }\n                    }\n                    \n                    bucket.saveField(iType, value);\n                    return position;\n                }\n            }\n\n            int year;\n            char c = text.charAt(position);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = c - '0';\n            c = text.charAt(position + 1);\n            if (c < '0' || c > '9') {\n                return ~position;\n            }\n            year = ((year << 3) + (year << 1)) + c - '0';\n\n            int pivot = iPivot;\n            // If the bucket pivot year is non-null, use that when parsing\n            if (bucket.getPivotYear() != null) {\n                pivot = bucket.getPivotYear().intValue();\n            }\n\n            int low = pivot - 50;\n\n            int t;\n            if (low >= 0) {\n                t = low % 100;\n            } else {\n                t = 99 + ((low + 1) % 100);\n            }\n\n            year += low + ((year < t) ? 100 : 0) - t;\n\n            bucket.saveField(iType, year);\n            return position + 2;\n        }"
}