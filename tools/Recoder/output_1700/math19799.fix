{
          "0": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "1": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nreturn null;            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "2": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans != INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "3": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nreturn dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "4": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nfield.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "5": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nreturn result;            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "6": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nresult.nans = QNAN;\n            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "7": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nresult = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "8": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nshiftLeft();\n            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n}\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "9": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nshiftRight();\n            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n}\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "10": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((x.nans == INFINITE) && (nans == INFINITE))){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "11": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(negativeOrNull()){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "12": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(strictlyNegative()){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "13": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(positiveOrNull()){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "14": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(strictlyPositive()){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "15": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(isInfinite()){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "16": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(isNaN()){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "17": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(isZero()){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "18": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == FINITE)){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "19": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans >= INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "20": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((sign != x.sign)){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "21": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "22": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nreturn false;            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "23": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nreturn x;            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "24": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((x.nans == INFINITE)){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "25": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nreturn \"null\";            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "26": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == INFINITE)){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "27": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nreturn true;            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "28": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nbreak;\n            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "29": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans > INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "30": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == FINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "31": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == SNAN)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "32": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == QNAN)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "33": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == sign)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "34": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == nans)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "35": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nreturn this;            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "36": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) && (sign != x.sign))){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "37": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == result)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "38": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nreturn;\n            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "39": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans <= INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "40": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((FINITE == INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "41": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((INFINITE == INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "42": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((SNAN == INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "43": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((QNAN == INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "44": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((sign == INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "45": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((result == INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "46": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) || (sign != x.sign))){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "47": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) && (sign == x.sign))){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "48": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) && negativeOrNull())){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "49": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) && strictlyNegative())){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "50": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) && positiveOrNull())){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "51": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) && strictlyPositive())){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "52": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) && isInfinite())){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "53": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) && isNaN())){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "54": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(((nans == INFINITE) && isZero())){\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "55": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(negativeOrNull()){\nreturn null;}            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "56": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(strictlyNegative()){\nreturn null;}            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "57": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(positiveOrNull()){\nreturn null;}            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "58": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(strictlyPositive()){\nreturn null;}            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "59": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(isInfinite()){\nreturn null;}            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "60": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(isNaN()){\nreturn null;}            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "61": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif(isZero()){\nreturn null;}            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "62": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans == ADD_TRAP)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "63": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((nans < INFINITE)){                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "64": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\ncontinue;\n            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "65": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nif((result != null)){\nreturn null;}            if (nans == INFINITE) {                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }",
          "66": "    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\nbreak;\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }"
}