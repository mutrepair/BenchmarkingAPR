{
          "0": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((wrapperName != null)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "1": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName == null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "2": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "3": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((unwrappedNames != null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "4": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) || true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "5": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(wrapperName){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "6": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) && false)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "7": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName > null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "8": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName >= null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "9": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((_delegatee != null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "10": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && (wrapperName != null))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "11": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(!wrapperName){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "12": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((type != null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "13": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName <= null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "14": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName < null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "15": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((_type != null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "16": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((prop != null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "17": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) && true)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "18": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(unwrappedNames){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "19": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != false) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "20": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nunwrappedNames = new HashSet<String>();\n            if (wrapperName != null && true) {                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "21": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) && (wrapperName != null))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "22": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((unwrappedNames == null)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "23": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(prop.getType()){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "24": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((del != null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "25": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "26": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && (wrapperName == null))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "27": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((( != null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "28": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((wrapperName != null)){\n            if (wrapperName != null && true) {                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n}\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "29": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && wrapperName)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "30": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName && null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "31": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(it.next()){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "32": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(prop.getWrapperName()){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "33": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(newDelegatee.properties()){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "34": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(wrapperName.isEmpty()){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "35": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && (wrapperName != true))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "36": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && (unwrappedNames == null))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "37": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((wrapperName != true)){\ncontinue;\n}            if (wrapperName != null && true) {                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "38": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((wrapperName && ((wrapperName != null) && true))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "39": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(!TypeUtil.isIndexedType(type)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "40": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((wrapperName != true)){\n            if (wrapperName != null && true) {                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n}\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "41": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && (wrapperName == true))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "42": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((it != null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "43": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && true)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "44": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((wrapperName == true)){\ncontinue;\n}            if (wrapperName != null && true) {                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "45": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(type){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "46": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && !wrapperName)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "47": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nunwrappedNames.add(prop.getName());\n            if (wrapperName != null && true) {                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "48": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && wrapperName.isEmpty())){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "49": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((wrapperName != null)){\ncontinue;\n}            if (wrapperName != null && true) {                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "50": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && ((wrapperName != null) && true))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "51": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName || null) && true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "52": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && unwrappedNames)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "53": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "54": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) && ((wrapperName != null) && true))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "55": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && !wrapperName.isEmpty())){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "56": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(_delegatee){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "57": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && (wrapperName != null)) && true)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "58": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(!wrapperName.isEmpty()){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "59": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) && (wrapperName == null))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "60": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((((wrapperName != null) && true) && (wrapperName != null)) && true)){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "61": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(_type){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "62": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(!unwrappedNames){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "63": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) != true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "64": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) && null)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "65": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) == true)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "66": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif(((wrapperName != null) && 1)){                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }",
          "67": "    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n            BeanProperty property)\n        throws JsonMappingException\n    {\n        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n        /*\n        JavaType vt = _type;\n        if (vt == null) {\n            vt = ctxt.constructType(_delegatee.handledType());\n        }\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n        */\n\n        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n        BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n        \n        // Let's go through the properties now...\n        Iterator<SettableBeanProperty> it = newDelegatee.properties();\n        HashSet<String> unwrappedNames = null;\n        while (it.hasNext()) {\n            SettableBeanProperty prop = it.next();\n            /* First things first: only consider array/Collection types\n             * (not perfect check, but simplest reasonable check)\n             */\n            JavaType type = prop.getType();\n            if (!TypeUtil.isIndexedType(type)) {\n                continue;\n            }\n            PropertyName wrapperName = prop.getWrapperName();\n            // skip anything with wrapper (should work as is)\nif((((wrapperName != null) && true) && (wrapperName == wrapperName))){\n                continue;\n            }\n            if (unwrappedNames == null) {\n                unwrappedNames = new HashSet<String>();\n            }\n            // not optimal; should be able to use PropertyName...\n            unwrappedNames.add(prop.getName());\n        }\n        // Ok: if nothing to take care of, just return the delegatee...\n        if (unwrappedNames == null) {\n            return newDelegatee;\n        }\n        // Otherwise, create the thing that can deal with virtual wrapping\n        return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n    }"
}