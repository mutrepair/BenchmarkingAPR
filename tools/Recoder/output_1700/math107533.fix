{
          "0": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "1": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "2": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "3": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "4": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destOddStartIndex + r)] = ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "5": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nwSubN0ToRI = nextWsubN0ToRI;\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "6": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nwSubN0ToRR = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "7": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nreturn;\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "8": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nwSubN0ToRR = nextWsubN0ToRR;\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "9": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nbreak;\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "10": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destOddStartIndex + r)] = (grI - ((wSubN0ToRR * hrI) + (wSubN0ToRI * hrR)));\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "11": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destEvenStartIndex + r)] = ((grI + (wSubN0ToRR * hrI)) + (wSubN0ToRI * hrR));\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "12": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nwSubN0ToRR = ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "13": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nwSubN0ToRI = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "14": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destEvenStartIndex + r)] = ((grR + (wSubN0ToRR * hrR)) - (wSubN0ToRI * hrI));\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "15": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nwSubN0ToRI = ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "16": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (wSubN0ToRR * hrR);\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "17": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (wSubN0ToRI % hrI);\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "18": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] += (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "19": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (hrR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "20": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destOddStartIndex + r)] = (wSubN0ToRR * hrR);\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "21": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destOddStartIndex + r)] += (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "22": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destOddStartIndex + r)] = (wSubN0ToRI % hrI);\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "23": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(hrR + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "24": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nwSubN0ToRI = nextWsubN0ToRI;\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "25": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrR)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "26": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destEvenStartIndex + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "27": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (destOddStartIndex + r);\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "28": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (hrI - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "29": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nwSubN0ToRR = nextWsubN0ToRR;\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "30": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * hrI) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "31": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nfor(int r = 0;(r < lastN0);r++) {                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "32": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destEvenStartIndex + r)] = ((grR + (wSubN0ToRR * hrR)) - (wSubN0ToRI * hrI));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "33": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destOddStartIndex + r)] = ((wSubN0ToRR * hrI) + (wSubN0ToRI * hrR));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "34": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((hrR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "35": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + hrR)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "36": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nif((r < lastN0)){\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n}\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "37": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nhrR = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "38": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(hrI + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "39": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI))) + hrR);\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "40": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((wSubN0ToRR * hrI) + (wSubN0ToRI * hrR));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "41": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] += ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "42": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * hrR) - (hrR % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "43": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destOddStartIndex + r)] = (grI - ((wSubN0ToRR * hrI) + (wSubN0ToRI * hrR)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "44": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (r - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "45": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ncontinue;\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "46": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * r) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "47": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nhrI = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "48": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((hrI * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "49": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + hrI)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "50": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grI - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "51": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(r + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "52": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * grR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "53": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * grI) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "54": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * hrR) - (hrI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "55": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(grR + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "56": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nif((wSubN0ToRI % hrI)){\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n}\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "57": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\nr = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "58": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % r)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "59": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(grI + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "60": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % grR)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "61": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((r * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "62": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (wSubN0ToRR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "63": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((wSubN0ToRR * hrR) - (wSubN0ToRI % grI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "64": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataI[(destEvenStartIndex + r)] = ((grI + (wSubN0ToRR * hrI)) + (wSubN0ToRI * hrR));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "65": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = (grR - ((grR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "66": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\n                    dataR[destOddStartIndex + r] = grR - (wSubN0ToRR * hrR - wSubN0ToRI % hrI);                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "67": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((((hrR - hrR) - dataR) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI))) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "68": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((((hrR - dataR) - dataR) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI))) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "69": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((((hrR - hrR) + dataR) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI))) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "70": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((((hrR - dataR) + dataR) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI))) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "71": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((((hrR - hrR) - destOddStartIndex) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI))) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "72": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((((hrR - hrR) - dataR) + (wSubN0ToRI % hrI)) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "73": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((((hrR - hrR) - dataR) + dataR) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }",
          "74": "    public static void transformInPlace(final double[][] dataRI,\n        final DftNormalization normalization, final TransformType type) {\n\n        if (dataRI.length != 2) {\n            throw new DimensionMismatchException(dataRI.length, 2);\n        }\n        final double[] dataR = dataRI[0];\n        final double[] dataI = dataRI[1];\n        if (dataR.length != dataI.length) {\n            throw new DimensionMismatchException(dataI.length, dataR.length);\n        }\n\n        final int n = dataR.length;\n        if (!ArithmeticUtils.isPowerOfTwo(n)) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING,\n                Integer.valueOf(n));\n        }\n\n        if (n == 1) {\n            return;\n        } else if (n == 2) {\n            final double srcR0 = dataR[0];\n            final double srcI0 = dataI[0];\n            final double srcR1 = dataR[1];\n            final double srcI1 = dataI[1];\n\n            // X_0 = x_0 + x_1\n            dataR[0] = srcR0 + srcR1;\n            dataI[0] = srcI0 + srcI1;\n            // X_1 = x_0 - x_1\n            dataR[1] = srcR0 - srcR1;\n            dataI[1] = srcI0 - srcI1;\n\n            normalizeTransformedData(dataRI, normalization, type);\n            return;\n        }\n\n        bitReversalShuffle2(dataR, dataI);\n\n        // Do 4-term DFT.\n        if (type == TransformType.INVERSE) {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i1] = srcI0 - srcI2 + (srcR1 - srcR3);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i3] = srcI0 - srcI2 + (srcR3 - srcR1);\n            }\n        } else {\n            for (int i0 = 0; i0 < n; i0 += 4) {\n                final int i1 = i0 + 1;\n                final int i2 = i0 + 2;\n                final int i3 = i0 + 3;\n\n                final double srcR0 = dataR[i0];\n                final double srcI0 = dataI[i0];\n                final double srcR1 = dataR[i2];\n                final double srcI1 = dataI[i2];\n                final double srcR2 = dataR[i1];\n                final double srcI2 = dataI[i1];\n                final double srcR3 = dataR[i3];\n                final double srcI3 = dataI[i3];\n\n                // 4-term DFT\n                // X_0 = x_0 + x_1 + x_2 + x_3\n                dataR[i0] = srcR0 + srcR1 + srcR2 + srcR3;\n                dataI[i0] = srcI0 + srcI1 + srcI2 + srcI3;\n                // X_1 = x_0 - x_2 + j * (x_3 - x_1)\n                dataR[i1] = srcR0 - srcR2 + (srcI1 - srcI3);\n                dataI[i1] = srcI0 - srcI2 + (srcR3 - srcR1);\n                // X_2 = x_0 - x_1 + x_2 - x_3\n                dataR[i2] = srcR0 - srcR1 + srcR2 - srcR3;\n                dataI[i2] = srcI0 - srcI1 + srcI2 - srcI3;\n                // X_3 = x_0 - x_2 + j * (x_1 - x_3)\n                dataR[i3] = srcR0 - srcR2 + (srcI3 - srcI1);\n                dataI[i3] = srcI0 - srcI2 + (srcR1 - srcR3);\n            }\n        }\n\n        int lastN0 = 4;\n        int lastLogN0 = 2;\n        while (lastN0 < n) {\n            int n0 = lastN0 << 1;\n            int logN0 = lastLogN0 + 1;\n            double wSubN0R = W_SUB_N_R[logN0];\n            double wSubN0I = W_SUB_N_I[logN0];\n            if (type == TransformType.INVERSE) {\n                wSubN0I = -wSubN0I;\n            }\n\n            // Combine even/odd transforms of size lastN0 into a transform of size N0 (lastN0 * 2).\n            for (int destEvenStartIndex = 0; destEvenStartIndex < n; destEvenStartIndex += n0) {\n                int destOddStartIndex = destEvenStartIndex + lastN0;\n\n                double wSubN0ToRR = 1;\n                double wSubN0ToRI = 0;\n\n                for (int r = 0; r < lastN0; r++) {\n                    double grR = dataR[destEvenStartIndex + r];\n                    double grI = dataI[destEvenStartIndex + r];\n                    double hrR = dataR[destOddStartIndex + r];\n                    double hrI = dataI[destOddStartIndex + r];\n\n                    // dest[destEvenStartIndex + r] = Gr + WsubN0ToR * Hr\n                    dataR[destEvenStartIndex + r] = grR + wSubN0ToRR * hrR - wSubN0ToRI * hrI;\n                    dataI[destEvenStartIndex + r] = grI + wSubN0ToRR * hrI + wSubN0ToRI * hrR;\n                    // dest[destOddStartIndex + r] = Gr - WsubN0ToR * Hr\ndataR[(destOddStartIndex + r)] = ((((hrR - dataR) - dataR) + dataR) + ((wSubN0ToRR * hrR) - (wSubN0ToRI % hrI)));\n                    dataI[destOddStartIndex + r] = grI - (wSubN0ToRR * hrI + wSubN0ToRI * hrR);\n\n                    // WsubN0ToR *= WsubN0R\n                    double nextWsubN0ToRR = wSubN0ToRR * wSubN0R - wSubN0ToRI * wSubN0I;\n                    double nextWsubN0ToRI = wSubN0ToRR * wSubN0I + wSubN0ToRI * wSubN0R;\n                    wSubN0ToRR = nextWsubN0ToRR;\n                    wSubN0ToRI = nextWsubN0ToRI;\n                }\n            }\n\n            lastN0 = n0;\n            lastLogN0 = logN0;\n        }\n\n        normalizeTransformedData(dataRI, normalization, type);\n    }"
}