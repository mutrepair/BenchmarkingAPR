{
          "0": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "1": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 0) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "2": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >>> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "3": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "4": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 & 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "5": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 1) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "6": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nfinal byte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "7": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 >> SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "8": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 % 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "9": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 >>> SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "10": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 >> 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "11": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 >>> 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "12": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 <= 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "13": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 >= 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "14": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 | 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "15": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 <= 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "16": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 - 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "17": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((val1 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "18": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >= 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "19": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 > 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "20": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 > 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "21": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 3);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "22": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & val1) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "23": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 % SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "24": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 < 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "25": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> -1);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "26": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 > SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "27": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 % 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "28": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 - 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "29": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 <= SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "30": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 & 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "31": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 - SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "32": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 < 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "33": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) >> 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "34": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) <= 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "35": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 >= SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "36": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) >>> 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "37": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xc0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "38": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 != 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "39": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((lookUpBase64Alphabet & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "40": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) >= 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "41": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) > 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "42": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & CHUNK_SIZE) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "43": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & BASELENGTH) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "44": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & LOOKUPLENGTH) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "45": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & EIGHTBIT) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "46": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIXTEENBIT) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "47": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & TWENTYFOURBITGROUP) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "48": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & FOURBYTE) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "49": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 2);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "50": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & lookUpBase64Alphabet) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "51": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << -1) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "52": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) - 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "53": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((encodedData & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "54": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nencodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "55": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 3) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "56": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 < SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "57": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 4);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "58": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & encodedData) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "59": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) % 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "60": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nk = (byte)(b1 & 0x03);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "61": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) & 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "62": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nl = (byte)(b2 & 0x0f);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "63": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) < 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "64": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nb2 = binaryData[(dataIndex + 1)];\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "65": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nencodedData[(encodedIndex + 2)] = lookUpBase64Alphabet[(l << 2)];\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "66": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((encodedIndex & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "67": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((PAD & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "68": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 | SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "69": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nencodedData[(encodedIndex + 1)] = lookUpBase64Alphabet[(val2 | (k << 4))];\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "70": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & encodedIndex) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "71": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 0xc0) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "72": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & PAD) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "73": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) != 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "74": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 2) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "75": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nb1 = binaryData[dataIndex];\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "76": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nencodedData[(encodedIndex + 3)] = PAD;\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "77": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nreturn;\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "78": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 1);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "79": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "80": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "81": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "82": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbreak;\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) << 4 ^ 0xf0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }",
          "83": "    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked) {\n        long binaryDataLength = binaryData.length;\n        long lengthDataBits = binaryDataLength * EIGHTBIT;\n        long fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n        long tripletCount = lengthDataBits / TWENTYFOURBITGROUP;\n        long encodedDataLengthLong = 0;\n        int chunckCount = 0;\n\n        if (fewerThan24bits != 0) {\n            // data not divisible by 24 bit\n            encodedDataLengthLong = (tripletCount + 1) * 4;\n        } else {\n            // 16 or 8 bit\n            encodedDataLengthLong = tripletCount * 4;\n        }\n\n        // If the output is to be \"chunked\" into 76 character sections,\n        // for compliance with RFC 2045 MIME, then it is important to\n        // allow for extra length to account for the separator(s)\n        if (isChunked) {\n\n            chunckCount = (CHUNK_SEPARATOR.length == 0 ? 0 : (int) Math\n                    .ceil((float) encodedDataLengthLong / CHUNK_SIZE));\n            encodedDataLengthLong += chunckCount * CHUNK_SEPARATOR.length;\n        }\n\n        if (encodedDataLengthLong > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\n                    \"Input array too big, output array would be bigger than Integer.MAX_VALUE=\" + Integer.MAX_VALUE);\n        }\n        int encodedDataLength = (int) encodedDataLengthLong;\n        byte encodedData[] = new byte[encodedDataLength];\n\n        byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int encodedIndex = 0;\n        int dataIndex = 0;\n        int i = 0;\n        int nextSeparatorIndex = CHUNK_SIZE;\n        int chunksSoFar = 0;\n\n        // log.debug(\"number of triplets = \" + numberTriplets);\n        for (i = 0; i < tripletCount; i++) {\n            dataIndex = i * 3;\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            b3 = binaryData[dataIndex + 2];\n\n            // log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            byte val2 = ((b2 & SIGN) == 0) ? (byte) (b2 >> 4) : (byte) ((b2) >> 4 ^ 0xf0);\n            byte val3 = ((b3 & SIGN) == 0) ? (byte) (b3 >> 6) : (byte) ((b3) >> 6 ^ 0xfc);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            // log.debug( \"val2 = \" + val2 );\n            // log.debug( \"k4 = \" + (k<<4) );\n            // log.debug( \"vak = \" + (val2 | (k<<4)) );\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[(l << 2) | val3];\n            encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n\n            encodedIndex += 4;\n\n            // If we are chunking, let's put a chunk separator down.\n            if (isChunked) {\n                // this assumes that CHUNK_SIZE % 4 == 0\n                if (encodedIndex == nextSeparatorIndex) {\n                    System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedIndex, CHUNK_SEPARATOR.length);\n                    chunksSoFar++;\n                    nextSeparatorIndex = (CHUNK_SIZE * (chunksSoFar + 1)) + (chunksSoFar * CHUNK_SEPARATOR.length);\n                    encodedIndex += CHUNK_SEPARATOR.length;\n                }\n            }\n        }\n\n        // form integral number of 6-bit groups\n        dataIndex = i * 3;\n\n        if (fewerThan24bits == EIGHTBIT) {\n            b1 = binaryData[dataIndex];\n            k = (byte) (b1 & 0x03);\n            // log.debug(\"b1=\" + b1);\n            // log.debug(\"b1<<2 = \" + (b1>>2) );\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n            encodedData[encodedIndex + 2] = PAD;\n            encodedData[encodedIndex + 3] = PAD;\n        } else if (fewerThan24bits == SIXTEENBIT) {\n\n            b1 = binaryData[dataIndex];\n            b2 = binaryData[dataIndex + 1];\n            l = (byte) (b2 & 0x0f);\n            k = (byte) (b1 & 0x03);\n\n            byte val1 = ((b1 & SIGN) == 0) ? (byte) (b1 >> 2) : (byte) ((b1) >> 2 ^ 0xc0);\nbyte val2 = (((b2 & SIGN) == 0))?(byte)(b2 >> 4):(((b2 & SIGN) == 0))?(byte)(b2 >> 4):(((b2 & SIGN) == 0))?(byte)(b2 >> 4):(byte)((b2 << 4) ^<> 0xf0);\n\n            encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n            encodedData[encodedIndex + 1] = lookUpBase64Alphabet[val2 | (k << 4)];\n            encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n            encodedData[encodedIndex + 3] = PAD;\n        }\n\n        if (isChunked) {\n            // we also add a separator to the end of the final chunk.\n            if (chunksSoFar < chunckCount) {\n                System.arraycopy(CHUNK_SEPARATOR, 0, encodedData, encodedDataLength - CHUNK_SEPARATOR.length,\n                        CHUNK_SEPARATOR.length);\n            }\n        }\n\n        return encodedData;\n    }"
}