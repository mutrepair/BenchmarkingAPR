{
          "0": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "1": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "2": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nbreak;\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "3": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.remove(i);\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "4": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(2, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "5": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(1, i);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "6": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nidProp = prop;\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "7": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "8": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\ngen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "9": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\ngen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "10": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "11": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(false, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "12": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "13": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\ncontinue;\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "14": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(1, propName);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "15": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(true, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "16": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nidProp = prop;\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "17": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.remove(i);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "18": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(1, len);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "19": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((idProp != 0)){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "20": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\npropName.add(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "21": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(1, implClass);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "22": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nreturn ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "23": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\ngen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "24": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nreturn ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "25": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\ngen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "26": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nidProp = props.add(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "27": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((i > 0)){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "28": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, 0);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "29": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.remove(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "30": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nreturn;\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "31": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif(((\"null\" + beanDesc.getBeanClass().getName()) + \"null\")){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "32": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nObjectIdWriter.add(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "33": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif(props.add(1, idProp)){\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "34": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nobjectIdInfo.add(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "35": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, i);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "36": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((i != 0)){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "37": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(-1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "38": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.construct(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "39": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nfor(int i = 0,i = 0;;++i) {                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "40": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((((\"null\" + beanDesc.getBeanClass().getName()) + \"null\") + propName)){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "41": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((\"null\" + beanDesc.getBeanClass().getName())){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "42": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprov.add(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "43": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif(propName.equals(prop.getName())){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "44": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((i == len)){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "45": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(null, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "46": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nObjectIdWriter.add(idProp, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "47": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.objectIdGeneratorInstance(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "48": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(\"null\", idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "49": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, idProp, 0);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "50": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((propName != 0)){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "51": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((implClass == PropertyGenerator)){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "52": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\ni.add(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "53": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nreturn null;                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "54": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, propName);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "55": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(1, gen);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "56": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(1, prop);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "57": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nObjectIdWriter.add(idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "58": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((idProp != null)){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "59": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((objectIdInfo == null)){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "60": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nObjectIdWriter.remove(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "61": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nObjectIdWriter.remove(idProp, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "62": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nlen.add(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "63": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, 0, 0);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "64": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nif((idProp != \"null\")){\n}\n                        props.add(1, idProp);                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "65": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprov.add(idProp, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "66": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(1, objectIdInfo);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "67": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, 1);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "68": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, 0, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "69": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.debug(1, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "70": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, false);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "71": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, idProp, false);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "72": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, objectIdInfo);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "73": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nObjectIdWriter.construct(idProp, idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "74": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprov.add(idProp);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }",
          "75": "    protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov,\n            BeanDescription beanDesc, List<BeanPropertyWriter> props)\n        throws JsonMappingException\n    {\n        ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();\n        if (objectIdInfo == null) {\n            return null;\n        }\n        ObjectIdGenerator<?> gen;\n        Class<?> implClass = objectIdInfo.getGeneratorType();\n\n        // Just one special case: Property-based generator is trickier\n        if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work\n            String propName = objectIdInfo.getPropertyName();\n            BeanPropertyWriter idProp = null;\n\n            for (int i = 0, len = props.size() ;; ++i) {\n                if (i == len) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \"+beanDesc.getBeanClass().getName()\n                            +\": can not find property with name '\"+propName+\"'\");\n                }\n                BeanPropertyWriter prop = props.get(i);\n                if (propName.equals(prop.getName())) {\n                    idProp = prop;\n                    /* Let's force it to be the first property to output\n                     * (although it may still get rearranged etc)\n                     */\n                    if (i > 0) {\n                        props.remove(i);\nprops.add(idProp, true);\n                    }\n                    break;\n                }\n            }\n            JavaType idType = idProp.getType();\n            gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n            // one more thing: must ensure that ObjectIdWriter does not actually write the value:\n            return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId());\n            \n        } \n        // other types are simpler\n        JavaType type = prov.constructType(implClass);\n        // Could require type to be passed explicitly, but we should be able to find it too:\n        JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n        gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo);\n        return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,\n                objectIdInfo.getAlwaysAsId());\n    }"
}