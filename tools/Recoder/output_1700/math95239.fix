{
          "0": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + v) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "1": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + DEFAULT_EPSILON) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "2": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "3": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + DELTA) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "4": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((0 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "5": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(v)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "6": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + u) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "7": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn ((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "8": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (-0.5 - FastMath.log(b));            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "9": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + w) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "10": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((1 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "11": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + v) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "12": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(u)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "13": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - v) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "14": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 * FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - v) - u);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "15": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + b) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "16": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn ((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "17": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + a) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "18": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "19": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((2 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "20": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.sumDeltaMinusDeltaSum(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "21": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(h)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "22": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(w)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "23": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + u) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "24": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) + u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "25": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log()) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "26": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 * FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - v) - u);                return (((-0.5 - FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "27": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - u);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "28": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(a)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "29": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log1p(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "30": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-1 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "31": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - w) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "32": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + b) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "33": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - w);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "34": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + ) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "35": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + h) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "36": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - b) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "37": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) <= u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "38": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - ) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "39": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + HALF_LOG_TWO_PI) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "40": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + a) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "41": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - h) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "42": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - h);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "43": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + -v) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "44": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - );            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "45": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nif((u <= v)){\n                return (((-0.5 - FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n}\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "46": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - b);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "47": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - HALF_LOG_TWO_PI) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "48": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn ((((-0.5 * FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "49": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (-0.5 * FastMath.log(b));            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "50": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - w.log(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "51": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - a) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "52": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn FastMath.log(b);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "53": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) / u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "54": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.debug(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "55": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - HALF_LOG_TWO_PI);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "56": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - a);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "57": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((10.0 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "58": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.add(b)) + HALF_LOG_TWO_PI) + w) - u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "59": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) >= u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "60": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nbreak;\n                return (((-0.5 - FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "61": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn (((((-0.5 - FastMath.log(b)) + HALF_LOG_TWO_PI) + w) == u) - v);            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "62": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\nreturn;\n                return (((-0.5 - FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }",
          "63": "    public static double logBeta(final double p, final double q) {\n        if (Double.isNaN(p) || Double.isNaN(q) || (p <= 0.0) || (q <= 0.0)) {\n            return Double.NaN;\n        }\n\n        final double a = FastMath.min(p, q);\n        final double b = FastMath.max(p, q);\n        if (a >= 10.0) {\n            final double w = sumDeltaMinusDeltaSum(a, b);\n            final double h = a / b;\n            final double c = h / (1.0 + h);\n            final double u = -(a - 0.5) * FastMath.log(c);\n            final double v = b * FastMath.log1p(h);\n            if (u <= v) {\ncontinue;\n                return (((-0.5 - FastMath.log(b) + HALF_LOG_TWO_PI) + w) - u) - v;            } else {\n                return (((-0.5 * FastMath.log(b) + HALF_LOG_TWO_PI) + w) - v) - u;\n            }\n        } else if (a > 2.0) {\n            if (b > 1000.0) {\n                final int n = (int) FastMath.floor(a - 1.0);\n                double prod = 1.0;\n                double ared = a;\n                for (int i = 0; i < n; i++) {\n                    ared -= 1.0;\n                    prod *= ared / (1.0 + ared / b);\n                }\n                return (FastMath.log(prod) - n * FastMath.log(b)) +\n                        (Gamma.logGamma(ared) +\n                         logGammaMinusLogGammaSum(ared, b));\n            } else {\n                double prod1 = 1.0;\n                double ared = a;\n                while (ared > 2.0) {\n                    ared -= 1.0;\n                    final double h = ared / b;\n                    prod1 *= h / (1.0 + h);\n                }\n                if (b < 10.0) {\n                    double prod2 = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod2 *= bred / (ared + bred);\n                    }\n                    return FastMath.log(prod1) +\n                           FastMath.log(prod2) +\n                           (Gamma.logGamma(ared) +\n                           (Gamma.logGamma(bred) -\n                            logGammaSum(ared, bred)));\n                } else {\n                    return FastMath.log(prod1) +\n                           Gamma.logGamma(ared) +\n                           logGammaMinusLogGammaSum(ared, b);\n                }\n            }\n        } else if (a >= 1.0) {\n            if (b > 2.0) {\n                if (b < 10.0) {\n                    double prod = 1.0;\n                    double bred = b;\n                    while (bred > 2.0) {\n                        bred -= 1.0;\n                        prod *= bred / (a + bred);\n                    }\n                    return FastMath.log(prod) +\n                           (Gamma.logGamma(a) +\n                            (Gamma.logGamma(bred) -\n                             logGammaSum(a, bred)));\n                } else {\n                    return Gamma.logGamma(a) +\n                           logGammaMinusLogGammaSum(a, b);\n                }\n            } else {\n                return Gamma.logGamma(a) +\n                       Gamma.logGamma(b) -\n                       logGammaSum(a, b);\n            }\n        } else {\n            if (b >= 10.0) {\n                return Gamma.logGamma(a) +\n                       logGammaMinusLogGammaSum(a, b);\n            } else {\n                // The following command is the original NSWC implementation.\n                // return Gamma.logGamma(a) +\n                // (Gamma.logGamma(b) - Gamma.logGamma(a + b));\n                // The following command turns out to be more accurate.\n                return FastMath.log(Gamma.gamma(a) * Gamma.gamma(b) /\n                                    Gamma.gamma(a + b));\n            }\n        }\n    }"
}