{
          "0": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < jBlock);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "1": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock <= blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "2": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "3": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockRows);jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "4": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = 1;(jBlock < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "5": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock >= blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "6": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = 2;(jBlock < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "7": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < BLOCK_SIZE);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "8": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < rows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "9": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < columns);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "10": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockColumns);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "11": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < iBlock);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "12": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock - blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "13": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < outBlock);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "14": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < -jBlock);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "15": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nbreak;\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "16": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int p = pStart;(p < pEnd);++p) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "17": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nreturn out;            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "18": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockRows);iBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "19": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((iBlock != null)){\ncontinue;\n}\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "20": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock > blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "21": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < (jBlock < blockRows));++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "22": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(iBlock < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "23": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock != null)){\ncontinue;\n}\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "24": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(blockRows < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "25": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int q = qStart;(q < qEnd);++q) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "26": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = 0;(jBlock < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "27": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(rows < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "28": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nreturn;\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "29": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n++blockIndex;\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "30": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\noutBlock[k] = tBlock[l];\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "31": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n++k;\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "32": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(columns < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "33": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockRows);-jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "34": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;;++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "35": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock == null)){\ncontinue;\n}\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "36": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock >> blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "37": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nl += lInc;\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "38": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockRows);rows) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "39": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nbreak;\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "40": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockRows);blockRows) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "41": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((iBlock == null)){\ncontinue;\n}\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "42": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockRows);columns) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "43": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < ~jBlock);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "44": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock == blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "45": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock == null)){\ncontinue;\n}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "46": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(outBlock < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "47": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -2;(jBlock < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "48": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock > 0)){\ncontinue;\n}\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "49": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock == 0)){\ncontinue;\n}\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "50": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < jBlock[((jBlock * blockColumns) + iBlock)]);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "51": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(-jBlock < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "52": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(blocks < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "53": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(BLOCK_SIZE < blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "54": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n((jBlock < (jBlock < blockRows)))\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "55": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((iBlock == null)){\ncontinue;\n}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "56": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < 0);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "57": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((iBlock == 0)){\ncontinue;\n}\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "58": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\ncontinue;\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "59": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int p = pStart;(p < pEnd);++p) {            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "60": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock == 0)){\ncontinue;\n}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "61": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock > 0)){\nbreak;\n}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "62": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < (jBlock < blockRows));++p) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "63": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock == null)){\nbreak;\n}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "64": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockRows);outBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "65": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\niBlock = iBlock;\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "66": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < blockRows);blocks) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "67": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock < 0)){\ncontinue;\n}\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "68": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((iBlock != 0)){\ncontinue;\n}\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "69": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((iBlock == null)){\nbreak;\n}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "70": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((iBlock == 0)){\ncontinue;\n}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "71": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock > 0)){\ncontinue;\n}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "72": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {if(0!=1)break;\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "73": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock == 0)){\nbreak;\n}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "74": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock >>> blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "75": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock / blockRows);++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "76": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nif((jBlock == null)){\nreturn out;}            for (int jBlock = -1; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "77": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor(int jBlock = -1;(jBlock < (blockRows - 0));++jBlock) {\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }"
}