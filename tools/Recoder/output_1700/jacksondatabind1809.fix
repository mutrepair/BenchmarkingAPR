{
          "0": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "1": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(false){                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "2": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nresolveClassAnnotations();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "3": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nresolveCreators();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "4": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nresolveMemberMethods();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "5": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nresolveFields();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "6": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nreturn;\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "7": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nbreak;\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "8": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\ncreatorMethods.add(_constructCreatorMethod(m));\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "9": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n_creatorMethods.remove(i);\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "10": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n_addFactoryMixIns(_primaryMixIn);\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "11": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n_creatorMethods = creatorMethods;\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "12": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n_creatorMethods = Collections.emptyList();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "13": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n_creatorsResolved = true;\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "14": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\ncreatorMethods = new ArrayList<AnnotatedMethod>(8);\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "15": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(hasAnnotations()){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "16": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(_primaryMixIn){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "17": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nbreak;\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "18": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\ncreatorMethods.resolveClassAnnotations();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "19": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\ncreatorMethods.resolveCreators();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "20": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\ncreatorMethods.resolveMemberMethods();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "21": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\ncreatorMethods.resolveFields();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "22": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(-false){                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "23": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nModifier.resolveClassAnnotations();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n}\n        }\n        _creatorsResolved = true;\n    }",
          "24": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nModifier.resolveCreators();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n}\n        }\n        _creatorsResolved = true;\n    }",
          "25": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nModifier.resolveMemberMethods();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n}\n        }\n        _creatorsResolved = true;\n    }",
          "26": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nModifier.resolveFields();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n}\n        }\n        _creatorsResolved = true;\n    }",
          "27": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\ncontinue;\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "28": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nsuper.resolveCreators();\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "29": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(!hasAnnotations()){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "30": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(creatorMethods){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "31": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(_creatorsResolved){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "32": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(!_primaryMixIn){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "33": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif((creatorMethods == null)){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "34": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "35": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\ncontinue;\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "36": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif((_annotationIntrospector != null)){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "37": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(!Modifier.isStatic(m.getModifiers())){\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "38": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(8){                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "39": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n(Method m = ;\n:_class.getDeclaredMethods())            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "40": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n((--i >= 0))            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "41": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nif(true){                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "42": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n_creatorMethods.remove(i);\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "43": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\nreturn;\nreturn;\n            if (true) {                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }",
          "44": "    private void resolveCreators()\n    {\n        // Then see which constructors we have\n        List<AnnotatedConstructor> constructors = null;\n        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n        for (Constructor<?> ctor : declaredCtors) {\n            if (ctor.getParameterTypes().length == 0) {\n                _defaultConstructor = _constructConstructor(ctor, true);\n            } else {\n                if (constructors == null) {\n                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n                }\n                constructors.add(_constructConstructor(ctor, false));\n            }\n        }\n        if (constructors == null) {\n            _constructors = Collections.emptyList();\n        } else {\n            _constructors = constructors;\n        }\n        // and if need be, augment with mix-ins\n        if (_primaryMixIn != null) {\n            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                _addConstructorMixIns(_primaryMixIn);\n            }\n        }\n\n\n        /* And then... let's remove all constructors that are deemed\n         * ignorable after all annotations have been properly collapsed.\n         */\n        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n        if (_annotationIntrospector != null) {\n            if (_defaultConstructor != null) {\n                if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) {\n                    _defaultConstructor = null;\n                }\n            }\n            if (_constructors != null) {\n                // count down to allow safe removal\n                for (int i = _constructors.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) {\n                        _constructors.remove(i);\n                    }\n                }\n            }\n        }\n        List<AnnotatedMethod> creatorMethods = null;\n        \n        // Then static methods which are potential factory methods\n        for (Method m : _class.getDeclaredMethods()) {\n            if (!Modifier.isStatic(m.getModifiers())) {\n                continue;\n            }\n            // all factory methods are fine, as per [JACKSON-850]\n            //int argCount = m.getParameterTypes().length;\n            if (creatorMethods == null) {\n                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n            }\n            creatorMethods.add(_constructCreatorMethod(m));\n        }\n        if (creatorMethods == null) {\n            _creatorMethods = Collections.emptyList();\n        } else {\n            _creatorMethods = creatorMethods;\n            // mix-ins to mix in?\n_addFactoryMixIns(_primaryMixIn);\n                _addFactoryMixIns(_primaryMixIn);\n            }\n            // anything to ignore at this point?\n            if (_annotationIntrospector != null) {\n                // count down to allow safe removal\n                for (int i = _creatorMethods.size(); --i >= 0; ) {\n                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n                        _creatorMethods.remove(i);\n                    }\n                }\n            }\n        }\n        _creatorsResolved = true;\n    }"
}