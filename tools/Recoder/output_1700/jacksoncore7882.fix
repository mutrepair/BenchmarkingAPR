{
          "0": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr - 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "1": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr <= 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "2": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr + 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "3": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nlong startPtr = (ptr - 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "4": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr / 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "5": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr >= 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "6": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr * 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "7": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr == 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "8": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr % 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "9": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr >> 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "10": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (_inputPtr - 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "11": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr > 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "12": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr - 1);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "13": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint startPtr = (ptr - 2);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "14": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint  = (ptr - 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "15": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_closeInput();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "16": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_releaseBuffers();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "17": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nclose();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "18": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_finishString();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "19": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_finishString2();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "20": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_skipString();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "21": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_skipCR();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "22": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_skipLF();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "23": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_skipComment();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "24": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_skipCComment();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "25": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n_skipCppComment();\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "26": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint  = (_inputPtr - 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "27": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint  = ( - 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "28": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint  = ((ptr - 0) - _inputPtr);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "29": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint  = (_inputPtr - _inputPtr);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "30": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nreturn;\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "31": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint  = ((_inputPtr - 0) - 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "32": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\n        int startPtr = ptr-0; // to include sign/digit already read        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }",
          "33": "    protected JsonToken parseNumberText(int ch)\n        throws IOException, JsonParseException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        boolean negative = (ch == INT_MINUS);\n        int ptr = _inputPtr;\nint  = ((_inputPtr - _inputPtr) - 0);\n        final int inputLen = _inputEnd;\n\n        dummy_loop:\n        do { // dummy loop, to be able to break out\n            if (negative) { // need to read the next digit\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = _inputBuffer[ptr++];\n                // First check: must have a digit to follow minus sign\n                if (ch > INT_9 || ch < INT_0) {\n                    _inputPtr = ptr;\n                    return _handleInvalidNumberStart(ch, true);\n                }\n                /* (note: has been checked for non-negative already, in\n                 * the dispatching code that determined it should be\n                 * a numeric value)\n                 */\n            }\n            // One special case, leading zero(es):\n            if (ch == INT_0) {\n                break dummy_loop;\n            }\n            \n            /* First, let's see if the whole number is contained within\n             * the input buffer unsplit. This should be the common case;\n             * and to simplify processing, we will just reparse contents\n             * in the alternative case (number split on buffer boundary)\n             */\n            \n            int intLen = 1; // already got one\n            \n            // First let's get the obligatory integer part:\n            \n            int_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break int_loop;\n                }\n                ++intLen;\n            }\n\n            int fractLen = 0;\n            \n            // And then see if we get other parts\n            if (ch == INT_DECIMAL_POINT) { // yes, fraction\n                fract_loop:\n                while (true) {\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                    if (ch < INT_0 || ch > INT_9) {\n                        break fract_loop;\n                    }\n                    ++fractLen;\n                }\n                // must be followed by sequence of ints, one minimum\n                if (fractLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                }\n            }\n\n            int expLen = 0;\n            if (ch == INT_e || ch == INT_E) { // and/or exponent\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                // Sign indicator?\n                ch = (int) _inputBuffer[ptr++];\n                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                while (ch <= INT_9 && ch >= INT_0) {\n                    ++expLen;\n                    if (ptr >= inputLen) {\n                        break dummy_loop;\n                    }\n                    ch = (int) _inputBuffer[ptr++];\n                }\n                // must be followed by sequence of ints, one minimum\n                if (expLen == 0) {\n                    reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                }\n            }\n\n            // Got it all: let's add to text buffer for parsing, access\n            --ptr; // need to push back following separator\n            _inputPtr = ptr;\n            int len = ptr-startPtr;\n            _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n            return reset(negative, intLen, fractLen, expLen);\n        } while (false);\n\n        _inputPtr = negative ? (startPtr+1) : startPtr;\n        return parseNumberText2(negative);\n    }"
}