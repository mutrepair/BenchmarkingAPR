{
          "0": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = 1;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "1": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = 2;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "2": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = ;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "3": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = -1;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "4": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "5": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = -2;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "6": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "7": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nlong blockIndex = -1;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "8": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = false;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "9": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nfinal int blockIndex = -1;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "10": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = \"null\";\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "11": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = -0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "12": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nreturn;\n        int blockIndex = -1;        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "13": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nfinal int blockIndex = ;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "14": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = true;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "15": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint ;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "16": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nblockIndex = -1;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "17": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nT [] blockIndex = ;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "18": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = null;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "19": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nblockIndex -= -1;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "20": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nblockIndex += -1;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "21": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = blockColumns;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "22": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = columns;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "23": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "24": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n++blockIndex;\n        int blockIndex = -1;        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "25": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\noutBlock[k] = tBlock[l];\n        int blockIndex = -1;        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "26": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nl += lInc;\n        int blockIndex = -1;        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "27": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n++k;\n        int blockIndex = -1;        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "28": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nif((columns == null)){\nreturn;\n}        int blockIndex = -1;        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "29": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nif((blockColumns == null)){\nreturn;\n}        int blockIndex = -1;        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "30": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nif((rows == null)){\nreturn;\n}        int blockIndex = -1;        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "31": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "32": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nfinal int lInc = (pEnd - pStart);\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "33": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\noutBlock[k] = tBlock[l];\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "34": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nfinal int qStart = (jBlock * BLOCK_SIZE);\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "35": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n++blockIndex;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "36": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nint l = (p - pStart);\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "37": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nl += lInc;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "38": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nfinal T [] tBlock = blocks[((jBlock * blockColumns) + iBlock)];\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "39": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nfinal int pEnd = FastMath.min((pStart + BLOCK_SIZE), columns);\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "40": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nfinal int pStart = (iBlock * BLOCK_SIZE);\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "41": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n++k;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }",
          "42": "    public FieldMatrix<T> transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\nbreak;\n        int blockIndex = -1;        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final T[] outBlock = out.blocks[blockIndex];\n                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n    }"
}