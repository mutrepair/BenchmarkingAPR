{
          "0": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "1": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT > t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "2": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT <= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "3": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT == t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "4": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT != t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "5": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT < t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "6": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >>> t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "7": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >> t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "8": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >= nextT):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "9": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT - t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "10": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT & t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "11": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal int nextIsLast = (forward)?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "12": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal double nextIsLast = (forward)?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "13": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal long nextIsLast = (forward)?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "14": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (nextT)?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "15": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nif((nextT != null)){\n          final boolean nextIsLast = forward ? (nextT >= t) : (true);          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n}\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "16": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (nextT >= t);\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "17": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >= t):false;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "18": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nif(nextT){\n          final boolean nextIsLast = forward ? (nextT >= t) : (true);          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n}\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "19": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nreturn;\n          final boolean nextIsLast = forward ? (nextT >= t) : (true);          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "20": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\ninterpolator.storeTime(stepStart);\n          final boolean nextIsLast = forward ? (nextT >= t) : (true);          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "21": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >= nextIsLast):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "22": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nif((nextT == null)){\n          final boolean nextIsLast = forward ? (nextT >= t) : (true);          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n}\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "23": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nstepSize = (t - stepStart);\n          final boolean nextIsLast = forward ? (nextT >= t) : (true);          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "24": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >= yDotTmp):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "25": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >= stepStart):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "26": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >= forward):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "27": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nif(!nextT){\n          final boolean nextIsLast = forward ? (nextT >= t) : (true);          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n}\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "28": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >= t):1;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "29": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = new boolean();\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "30": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nstepStart = acceptStep(interpolator, y, yDotTmp, t);\n          final boolean nextIsLast = forward ? (nextT >= t) : (true);          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "31": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextIsLast >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "32": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (boolean)(nextT >= t);\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "33": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(forward >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "34": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(stepStart >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "35": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(nextT >= t):0;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "36": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (forward)?(yDotTmp >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "37": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal double nextT = (stepStart + stepSize);\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "38": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nbreak;\n          final boolean nextIsLast = forward ? (nextT >= t) : (true);          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "39": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = ((nextT > nextT))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "40": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = ((nextT > 0))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "41": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = ((nextT < nextT))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "42": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = ((nextT >= nextT))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "43": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = ((nextT == nextT))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "44": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT >= t) && (nextT == nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "45": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (nextT >= t)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "46": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (nextT == nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "47": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (nextT != nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "48": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT == null) && (nextT == nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "49": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (nextT != null)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "50": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT == nextT) && (nextT == nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "51": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT == nextT) && (nextT != null)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "52": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (nextT == 0)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "53": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT == null) && (nextT != nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "54": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT == 0) && (nextT == nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "55": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != nextT) && (nextT != null)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "56": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT == nextT) && (nextT != nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "57": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (forward == nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "58": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != nextT) && (nextT == nextT)))?(nextT >= t):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "59": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (nextT != nextT)))?((nextT != null) && (nextT == nextT)):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "60": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (nextT != null)))?((nextT == nextT) && (nextT == nextT)):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "61": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (nextT != nextT)))?((nextT == null) && (nextT == nextT)):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }",
          "62": "  public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws NumberIsTooSmallException, DimensionMismatchException,\n             MaxCountExceededException, NoBracketingException {\n\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0      = equations.getCompleteState();\n    final double[] y       = y0.clone();\n    final int stages       = c.length + 1;\n    final double[][] yDotK = new double[stages][];\n    for (int i = 0; i < stages; ++i) {\n      yDotK [i] = new double[y0.length];\n    }\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart = equations.getTime();\n    stepSize  = forward ? step : -step;\n    initIntegration(equations.getTime(), y0, t);\n\n    // main integration loop\n    isLastStep = false;\n    do {\n\n      interpolator.shift();\n\n      // first stage\n      computeDerivatives(stepStart, y, yDotK[0]);\n\n      // next stages\n      for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n              double sum = a[k-1][0] * yDotK[0][j];\n              for (int l = 1; l < k; ++l) {\n                  sum += a[k-1][l] * yDotK[l][j];\n              }\n              yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n      }\n\n      // estimate the state at the end of the step\n      for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n              sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n      }\n\n      // discrete events handling\n      interpolator.storeTime(stepStart + stepSize);\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n\n      if (!isLastStep) {\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // stepsize control for next step\n          final double  nextT      = stepStart + stepSize;\nfinal boolean nextIsLast = (((nextT != null) && (nextT != nextT)))?((nextT == nextT) && (nextT == nextT)):true;\n          if (nextIsLast) {\n              stepSize = t - stepStart;\n          }\n      }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    stepStart = Double.NaN;\n    stepSize  = Double.NaN;\n\n  }"
}