{
          "0": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(false){        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "1": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "2": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((newProp != null)){\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n}\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "3": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(newProp){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "4": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nreturn;\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "5": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(propValue){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "6": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(objectToExtend.cloneTree()){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "7": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(!newProp){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "8": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(\"null\"){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "9": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((newProp == null)){\nreturn;\n}      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "10": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(\"null\"){\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n}\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "11": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((newProp != null)){\nreturn;\n}      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "12": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(-false){        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "13": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((propValue != null)){\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n}\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "14": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(n.getParent().isExprResult()){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "15": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(currentProp){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "16": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((newProp == null)){\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n}\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "17": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(!propValue){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "18": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((newProp || (fnc.getNext() != null))){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "19": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(fncBlock){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "20": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nbreak;\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "21": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(\"null\"){\nreturn;\n}      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "22": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(callTarget){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "23": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(newProp.isEmpty()){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "24": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(n.getParent().isExprResult()){\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n}\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "25": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(!assignNode){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "26": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nnewProp++;\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "27": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((newProp == null)){\ncontinue;\n}      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "28": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((newProp && (fnc.getNext() != null))){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "29": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((propValue == null)){\nreturn;\n}      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "30": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nbreak;\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "31": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nfncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "32": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nn.replaceChild(callTarget, fnc);\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "33": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nn.putBooleanProp(Node.FREE_CALL, true);\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "34": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\ncompiler.reportCodeChange();\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "35": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\ncurrentProp.setType(Token.STRING);\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "36": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nnewProp = IR.getelem(objectToExtend.cloneTree(), currentProp).srcref(currentProp);\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "37": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nfncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "38": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(extendArg.hasChildren()){\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n}\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "39": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nnewProp = IR.getprop(objectToExtend.cloneTree(), currentProp).srcref(currentProp);\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "40": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\ntargetVal = objectToExtend.removeFirstChild();\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "41": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(true){        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "42": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(true){\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n}\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "43": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(\"null\"){        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "44": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\ncontinue;\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "45": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((fnc.getNext() != null)){\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n}\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "46": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((newProp || (objectToExtend.cloneTree() == null))){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "47": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(((newProp != null) || (fnc.getNext() != null))){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "48": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nreturn;\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "49": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif((newProp || (newProp != null))){\n        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "50": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(null){        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "51": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nNode newProp = ;\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "52": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(\"null\"){        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "53": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nNode propValue = currentProp.removeFirstChild();\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "54": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nNode currentProp = extendArg.removeFirstChild();\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "55": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nNode targetVal = ;\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "56": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nNode assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }",
          "57": "  private void maybeExpandJqueryExtendCall(Node n) {\n    Node callTarget = n.getFirstChild();\n    Node objectToExtend = callTarget.getNext(); // first argument\n    Node extendArg = objectToExtend.getNext(); // second argument\n    boolean ensureObjectDefined = true;\n\n    if (extendArg == null) {\n      // Only one argument was specified, so extend jQuery namespace\n      extendArg = objectToExtend;\n      objectToExtend = callTarget.getFirstChild();\n      ensureObjectDefined = false;\n    } else if (objectToExtend.isGetProp() &&\n          (objectToExtend.getLastChild().getString().equals(\"prototype\") ||\n          convention.isPrototypeAlias(objectToExtend))) {\n      ensureObjectDefined = false;\n    }\n\n    // Check for an empty object literal\n    if (!extendArg.hasChildren()) {\n      return;\n    }\n\n    // Since we are expanding jQuery.extend calls into multiple statements,\n    // encapsulate the new statements in a new block.\n    Node fncBlock = IR.block().srcref(n);\n\n    if (ensureObjectDefined) {\n      Node assignVal = IR.or(objectToExtend.cloneTree(),\n          IR.objectlit().srcref(n)).srcref(n);\n      Node assign = IR.assign(objectToExtend.cloneTree(), assignVal).srcref(n);\n      fncBlock.addChildrenToFront(IR.exprResult(assign).srcref(n));\n    }\n\n    while (extendArg.hasChildren()) {\n      Node currentProp = extendArg.removeFirstChild();\n      currentProp.setType(Token.STRING);\n\n      Node propValue = currentProp.removeFirstChild();\n\n      Node newProp;\nif(((newProp != null) && (newProp != null))){\n      if(true) {        newProp = IR.getelem(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      } else {\n        newProp = IR.getprop(objectToExtend.cloneTree(),\n            currentProp).srcref(currentProp);\n      }\n\n      Node assignNode = IR.assign(newProp, propValue).srcref(currentProp);\n      fncBlock.addChildToBack(IR.exprResult(assignNode).srcref(currentProp));\n}\n    }\n\n    // Check to see if the return value is used. If not, replace the original\n    // call with new block. Otherwise, wrap the statements in an\n    // immediately-called anonymous function.\n    if (n.getParent().isExprResult()) {\n      Node parent = n.getParent();\n      parent.getParent().replaceChild(parent, fncBlock);\n    } else {\n      Node targetVal;\n      if (\"jQuery.prototype\".equals(objectToExtend.getQualifiedName())) {\n        // When extending the jQuery prototype, return the jQuery namespace.\n        // This is not commonly used.\n        targetVal = objectToExtend.removeFirstChild();\n      } else {\n        targetVal = objectToExtend.detachFromParent();\n      }\n      fncBlock.addChildToBack(IR.returnNode(targetVal).srcref(targetVal));\n\n      Node fnc = IR.function(IR.name(\"\").srcref(n),\n          IR.paramList().srcref(n),\n          fncBlock);\n      n.replaceChild(callTarget, fnc);\n      n.putBooleanProp(Node.FREE_CALL, true);\n\n      // remove any other pre-existing call arguments\n      while(fnc.getNext() != null) {\n        n.removeChildAfter(fnc);\n      }\n    }\n    compiler.reportCodeChange();\n  }"
}