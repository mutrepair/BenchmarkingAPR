{
          "0": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) * recipb);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "1": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (recipb * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "2": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "3": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) * );\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "4": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) * recipa);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "5": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (recip * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "6": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb = ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "7": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (recipa * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "8": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) * );\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "9": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - ( * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "10": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) * );\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "11": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += (((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb));\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "12": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipb)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "13": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - ( * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "14": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += (yab * recipb);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "15": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa));\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "16": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - recipb) - recipb) - (yab * recipa)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "17": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb = (((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb));\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "18": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recip)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "19": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb = (yab * recipb);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "20": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += (yab * recipa);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "21": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * )) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "22": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb = ((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa));\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "23": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - recip) - recipb) - (yab * recipa)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "24": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += (recip - recipa);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "25": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) - recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "26": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += (((1.0 - (yaa * recipa)) - yaa) - recipb);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "27": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - recipa) - recipb) - (yab * recipa)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "28": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) + recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "29": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - ) - recipb) - (yab * recipa)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "30": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * yab)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "31": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yab) - recipb) - (yab * recipa)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "32": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((-yb * recip) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "33": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recip)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "34": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * yab)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "35": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipa)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "36": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * )) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "37": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * recipa)) - yaa) - recipb) - (yab * recipa)) - (yab * yaa)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "38": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nrecipb += ((((((1.0 - (yaa * yaa)) - yaa) - recipb) - (yab * recipa)) - (yab * recipb)) * recip);\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "39": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\nreturn;\n          recipb += (1.0 - yaa*recipa - yaa - recipb - yab*recipa - yab*recipb) * recip;          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }",
          "40": "    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n          if (x >= LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(0.5 * x);\n              return (0.5 * t) * t;\n          } else {\n              return 0.5 * exp(x);\n          }\n      } else if (x < -20) {\n          if (x <= -LOG_MAX_VALUE) {\n              // Avoid overflow (MATH-905).\n              final double t = exp(-0.5 * x);\n              return (-0.5 * t) * t;\n          } else {\n              return -0.5 * exp(-x);\n          }\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa - recipb - yab*recipa - yab*recipb) * recip;          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }"
}