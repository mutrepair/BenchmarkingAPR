{
          "0": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "1": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = 2;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "2": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nlong attrCount = 1;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "3": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = null;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "4": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = false;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "5": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = true;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "6": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = \"null\";\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "7": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = -1;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "8": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint  = ;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "9": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint  = ;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "10": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = -2;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "11": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = 1;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "12": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = -0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "13": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nreturn;\n        int attrCount = 1;        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "14": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = Lit;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "15": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "16": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint bpw = ;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "17": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint  = ;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "18": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "19": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nBeanPropertyWriter attrCount = 1;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "20": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint  = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "21": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nboolean attrCount = 1;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "22": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = Lit;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "23": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = -1;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "24": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n_isAttribute(bpw);\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "25": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint  = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "26": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = Lit;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "27": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nObject attrCount = 1;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "28": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nint attrCount = 2;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "29": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nString attrCount = 1;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "30": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nList attrCount = 1;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "31": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\nbreak;\n        int attrCount = 1;        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "32": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 1;        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "33": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\ncontinue;\n        int attrCount = 1;        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }"
}