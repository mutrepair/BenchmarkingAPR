{
          "0": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((paramCount == (paramAnns.length + -2))){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "1": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length + 0)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "2": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "3": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount >= (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "4": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() || (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "5": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount <= (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "6": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount != (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "7": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount > (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "8": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((paramAnns.length + -2)){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "9": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (dc == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "10": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif(dc.isEnum()){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "11": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif(((dc.isEnum() && (paramCount == (paramAnns.length + -2))) && (paramCount == (paramAnns.length + -2)))){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "12": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length + -2)))){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "13": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length + -1)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "14": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length >= -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "15": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length == -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "16": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount - (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "17": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length <= -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "18": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount < (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "19": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (dc + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "20": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length != -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "21": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length > -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "22": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == ( + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "23": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.getName() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "24": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.getDeclaringClass() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "25": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramAnns == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "26": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount + (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "27": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount >> (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "28": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length + null)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "29": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length - -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "30": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((.isEnum() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "31": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (dc.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "32": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((\"null\" + ctor.getDeclaringClass().getName())){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "33": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "34": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif(((((\"null\" + ctor.getDeclaringClass().getName()) + \"null\") + paramCount) + \"null\")){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "35": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((((((\"null\" + ctor.getDeclaringClass().getName()) + \"null\") + paramCount) + \"null\") + paramAnns.length)){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "36": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && ( == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "37": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((((paramCount == (paramAnns.length + -2)) && (paramCount == (paramAnns.length + -2))) && (paramCount == (paramAnns.length + -2)))){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "38": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isMemberClass() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "39": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && ((paramCount == (paramAnns.length + -2)) && (paramCount == (paramAnns.length + -2))))){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "40": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((((\"null\" + ctor.getDeclaringClass().getName()) + \"null\") + paramCount)){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "41": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((ctor.isEnum() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "42": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif(((\"null\" + ctor.getDeclaringClass().getName()) + \"null\")){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "43": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif(hasAnnotations()){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "44": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length + 2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "45": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramCount + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "46": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount >>> (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "47": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length < -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "48": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((paramAnns.length + 1)){\n                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "49": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.isEnum() && (paramCount == (paramAnns.length + 1)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "50": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((.isEnum() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "51": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nreturn new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations);            if (dc.isEnum() && (paramCount == paramAnns.length + -2)) {                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "52": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc._constructConstructor() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "53": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((.isEnum() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "54": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nparamAnns = new Annotation[[]];\n            if (dc.isEnum() && (paramCount == paramAnns.length + -2)) {                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "55": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((old.isEnum() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "56": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nSystem.arraycopy(old, 0, paramAnns, 2, old.length);\n            if (dc.isEnum() && (paramCount == paramAnns.length + -2)) {                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "57": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nif((dc.getDeclaredAnnotations() && (paramCount == (paramAnns.length + -2)))){                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "58": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nreturn;\n            if (dc.isEnum() && (paramCount == paramAnns.length + -2)) {                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }",
          "59": "    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n    {\n        if (_annotationIntrospector == null) { // when annotation processing is disabled\n            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n        }\n        if (defaultCtor) {\n            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n        }\n        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n        int paramCount = ctor.getParameterTypes().length;\n        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n         * a bug. Alas, we can't really fix that...\n         */\n        // Also: [JACKSON-757] (enum value constructors)\n        AnnotationMap[] resolvedAnnotations = null;\n        if (paramCount != paramAnns.length) {\n            // Limits of the work-around (to avoid hiding real errors):\n            // first, only applicable for member classes and then either:\n\n            Class<?> dc = ctor.getDeclaringClass();\n            // (a) is enum, which have two extra hidden params (name, index)\nbreak;\n            if (dc.isEnum() && (paramCount == paramAnns.length + -2)) {                Annotation[][] old = paramAnns;\n                paramAnns = new Annotation[old.length+2][];\n                System.arraycopy(old, 0, paramAnns, 2, old.length);\n                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n            } else if (dc.isMemberClass()) {\n                // (b) non-static inner classes, get implicit 'this' for parameter, not  annotation\n                if (paramCount == (paramAnns.length + 1)) {\n                    // hack attack: prepend a null entry to make things match\n                    Annotation[][] old = paramAnns;\n                    paramAnns = new Annotation[old.length+1][];\n                    System.arraycopy(old, 0, paramAnns, 1, old.length);\n                    resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n                }\n            }\n            if (resolvedAnnotations == null) {\n                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n            }\n        } else {\n            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n        }\n        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n                resolvedAnnotations);\n    }"
}