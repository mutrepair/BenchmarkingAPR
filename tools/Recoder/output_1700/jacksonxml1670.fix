{
          "0": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "1": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "2": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 0,i = 0;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "3": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "4": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i <= len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "5": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "6": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i >= len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "7": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "8": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "9": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "10": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 2,i = 2;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "11": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "12": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "13": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "14": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "15": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "16": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "17": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "18": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "19": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "20": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < i);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "21": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "22": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "23": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "24": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i > len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "25": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "26": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);len) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "27": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;((textIndex < 0) && info.isText());++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "28": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(info != null);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "29": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(ns == null);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "30": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "31": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "32": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "33": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < _props.length);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "34": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "35": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "36": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(len < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "37": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "38": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n((i < len))            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "39": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < 0);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "40": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "41": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;;++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "42": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = -1,i = -1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "43": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "44": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(textIndex < 0);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "45": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "46": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "47": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "48": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "49": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "50": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "51": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(long i = 1,i = 1;(i < len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "52": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i == len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "53": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i - len);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "54": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(len < _props.length);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "55": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < (i < len));++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "56": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(len < 0);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "57": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i > _props.length);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "58": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(_props < i);++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "59": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n(;;)            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "60": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n((i < _props.length))            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "61": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nreturn;\n        for (int i = 1, len = _props.length; i < len; ++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "62": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < (_props.length - _props.length));++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "63": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;(i < (_props.length - 0));++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "64": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\nfor(int i = 1,i = 1;((i < len) || (i < _props.length));++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }",
          "65": "    public XmlBeanSerializerBase(BeanSerializerBase src)\n    {\n        super(src);\n\n        /* Then make sure attributes are sorted before elements, keep track\n         * of how many there are altogether\n         */\n        int attrCount = 0;\n        for (BeanPropertyWriter bpw : _props) {\n            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n                attrCount = _orderAttributesFirst(_props, _filteredProps);\n                break;\n            }\n        }\n        _attributeCount = attrCount;\n\n        // also: pre-compute need, if any, for CDATA handling:\n        BitSet cdata = null;\n        for (int i = 0, len = _props.length; i < len; ++i) {\n            BeanPropertyWriter bpw = _props[i];\n            if (_isCData(bpw)) {\n                if (cdata == null) {\n                    cdata = new BitSet(len);\n                }\n                cdata.set(i);\n            }\n        }\n        _cdata = cdata;\n        \n        // And then collect namespace information\n        _xmlNames = new QName[_props.length];\n        int textIndex = -1;\n        for (int i = 1, len = _props.length; i < len; ++i) {            BeanPropertyWriter bpw = _props[i];\n            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n            String ns = null;\n            if (info != null) {\n                ns = info.getNamespace();\n                if (textIndex < 0 && info.isText()) {\n                    textIndex = i;\n                }\n            }\n            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n        }\n        _textPropertyIndex = textIndex;\n    }"
}