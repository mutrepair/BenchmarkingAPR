{
          "0": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\n                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "1": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif(true){                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "2": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif(false){                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "3": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nreturn;\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "4": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nbreak;\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "5": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nprop = (SettableBeanProperty)pending[i];\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "6": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nprop.deserializeAndSet(jp, ctxt, throwable);\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "7": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nprop.set(throwable, pending[(i + 1)]);\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "8": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nthrowable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "9": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\npending[pendingIx++] = prop;\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "10": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\npending = null;\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "11": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\njp.skipChildren();\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "12": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\n_anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "13": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\npending[pendingIx++] = prop.deserialize(jp, ctxt);\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "14": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nbreak;\n                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "15": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif(-true){                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "16": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif((_ignorableProps != null)){\n                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "17": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\ncontinue;\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "18": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif((len + len)){\n                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "19": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif(PROP_NAME_MESSAGE.equals(propName)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "20": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif((i + 1)){\n                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "21": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif((_ignorableProps != null)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "22": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nfor(int i = 0,i = 0;(i < len);i += 2) {                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "23": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif(-false){                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "24": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif((len + len)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "25": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nthrowable = false;\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "26": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif((i + 1)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "27": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif(\"null\"){                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "28": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\ncontinue;\n                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "29": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nthrowable = true;\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "30": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif(2){                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "31": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif((propName != null)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "32": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif((pending != null)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "33": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif(((_ignorableProps != null) && _ignorableProps.contains(propName))){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "34": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif(PROP_NAME_MESSAGE.equals(propName)){\n                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "35": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif((pending != null)){\n                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "36": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif(((_ignorableProps != null) && _ignorableProps.contains(propName))){\n                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "37": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif((pending == null)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "38": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif((_anySetter != null)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "39": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif((throwable != null)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "40": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {                if (false) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n\nif((prop != null)){\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n}\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "41": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nif(1){                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }",
          "42": "    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n        throws IOException, JsonProcessingException\n    {\n        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n        if (_propertyBasedCreator != null) { // proper @JsonCreator\n            return _deserializeUsingPropertyBased(jp, ctxt);\n        }\n        if (_delegateDeserializer != null) {\n            return _valueInstantiator.createUsingDelegate(ctxt,\n                    _delegateDeserializer.deserialize(jp, ctxt));\n        }\n        if (_beanType.isAbstract()) { // for good measure, check this too\n            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n                    +\" (need to add/enable type information?)\");\n        }\n        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n        if (!hasStringCreator && !hasDefaultCtor) {\n            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n        }\n        \n        Object throwable = null;\n        Object[] pending = null;\n        int pendingIx = 0;\n\n        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n            String propName = jp.getCurrentName();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            jp.nextToken(); // to point to field value\n\n            if (prop != null) { // normal case\n                if (throwable != null) {\n                    prop.deserializeAndSet(jp, ctxt, throwable);\n                    continue;\n                }\n                // nope; need to defer\n                if (pending == null) {\n                    int len = _beanProperties.size();\n                    pending = new Object[len + len];\n                }\n                pending[pendingIx++] = prop;\n                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n                continue;\n            }\n\n            // Maybe it's \"message\"?\n            if (PROP_NAME_MESSAGE.equals(propName)) {\nfor(int i = 0,i = 0;(i < len);i += 2) {                    throwable = _valueInstantiator.createFromString(ctxt, jp.getText());\n                    // any pending values?\n                    if (pending != null) {\n                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n                            prop = (SettableBeanProperty)pending[i];\n                            prop.set(throwable, pending[i+1]);\n                        }\n                        pending = null;\n                    }\n                    continue;\n                }\n            }\n            /* As per [JACKSON-313], things marked as ignorable should not be\n             * passed to any setter\n             */\n            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                jp.skipChildren();\n                continue;\n            }\n            if (_anySetter != null) {\n                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n                continue;\n            }\n            // Unknown: let's call handler method\n            handleUnknownProperty(jp, ctxt, throwable, propName);\n        }\n        // Sanity check: did we find \"message\"?\n        if (throwable == null) {\n            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n             *   suppressed during serialization, as per [JACKSON-388].\n             *   \n             *   Should probably allow use of default constructor, too...\n             */\n            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n            if (hasStringCreator) {\n                throwable = _valueInstantiator.createFromString(ctxt, null);\n            } else {\n                throwable = _valueInstantiator.createUsingDefault(ctxt);\n            }\n            // any pending values?\n            if (pending != null) {\n                for (int i = 0, len = pendingIx; i < len; i += 2) {\n                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n                    prop.set(throwable, pending[i+1]);\n                }\n            }\n        }\n        return throwable;\n    }"
}