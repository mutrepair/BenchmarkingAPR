{
          "0": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value >= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "1": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value > 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "2": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "3": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value < 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "4": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((value <= 0)){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "5": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value > 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "6": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value <= 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "7": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((value >= 0)){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "8": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value < 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "9": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) || (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "10": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nvalue = jp.getIntValue();\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "11": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value == 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "12": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value == 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "13": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value || 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "14": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value != 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "15": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nreturn null;                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "16": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value != 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "17": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "18": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value && 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "19": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value >= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "20": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (t <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "21": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nreturn (Character)getEmptyValue();                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "22": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value <= 0)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "23": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((value >= 0)){\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n}\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "24": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((value <= 0)){\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n}\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "25": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nreturn Character.valueOf(text.charAt(0));                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "26": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && ((value >= 0) && (value <= 0)))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "27": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nreturn Character.valueOf((char)value);                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "28": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nreturn;\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "29": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (_valueClass <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "30": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nvalue = jp.getIntValue();\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "31": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nreturn value;                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "32": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value <= 2))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "33": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value || 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "34": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (text <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "35": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(value){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "36": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nbreak;\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "37": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value >= 0)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "38": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >>> 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "39": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((text.length() == 0)){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "40": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value & 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "41": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nvalue = value;\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "42": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value > value))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "43": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((t == JsonToken.VALUE_STRING)){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "44": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value < value))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "45": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value <= 0)) && (value >= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "46": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >> 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "47": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((text.length() == 1)){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "48": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (jp <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "49": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value && 0) && (value <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "50": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value >>> 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "51": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((text.length() == 0)){\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n}\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "52": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((value >= 0)){\nvalue = jp.getIntValue();\n}                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "53": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((value <= 0)){\nvalue = jp.getIntValue();\n}                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "54": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nvalue++;\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "55": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((t == JsonToken.VALUE_STRING)){\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n}\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "56": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value == value))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "57": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((text.length() == 1)){\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n}\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "58": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value >= value))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "59": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\ncontinue;\n                if (value >= 0 && value <= 0) {                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "60": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value <= 0)) && (value == value))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "61": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (ctxt <= 0))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "62": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value <= 0)) && (value > value))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "63": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value <= 0)) && (value < value))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "64": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value != value))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "65": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value == 0)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "66": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value == value)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "67": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value <= 0)) && (value != value))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "68": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value != null)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "69": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value == null)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "70": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value != 0)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "71": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif((((value >= 0) && (value != value)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "72": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((value >= 0) && (value <= 1))){                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "73": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((((value >= 0) && (value == 0)) && (value <= 0)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "74": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((((value >= 0) && (value == value)) && (value <= 0)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "75": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((((value >= 0) && (value != null)) && (value <= 0)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }",
          "76": "        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n            throws IOException, JsonProcessingException\n        {\n            JsonToken t = jp.getCurrentToken();\n            int value;\n\n            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n                value = jp.getIntValue();\nif(((((value >= 0) && (value == null)) && (value <= 0)) && (value <= 0))){\n                    return Character.valueOf((char) value);\n                }\n            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n                // But does it have to be exactly one char?\n                String text = jp.getText();\n                if (text.length() == 1) {\n                    return Character.valueOf(text.charAt(0));\n                }\n                // actually, empty should become null?\n                if (text.length() == 0) {\n                    return (Character) getEmptyValue();\n                }\n            }\n            throw ctxt.mappingException(_valueClass, t);\n        }"
}