{
          "0": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += ((hash * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "1": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "2": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "3": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * quads[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "4": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | MULT3[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "5": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * hash[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "6": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3[2]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "7": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += (hash >>> 3);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "8": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3[1]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "9": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "10": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | hash[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "11": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * DEFAULT_TABLE_SIZE[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "12": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MAX_TABLE_SIZE[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "13": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MAX_ENTRIES_FOR_REUSE[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "14": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MAX_COLL_CHAIN_LENGTH[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "15": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MAX_COLL_CHAIN_FOR_REUSE[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "16": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MIN_HASH_SIZE[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "17": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * INITIAL_COLLISION_LEN[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "18": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * LAST_VALID_BUCKET[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "19": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _hashSeed[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "20": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _count[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "21": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _longestCollisionList[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "22": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _mainHashMask[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "23": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _mainHash[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "24": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _collCount[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "25": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _collEnd[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "26": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "27": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT2[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "28": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * count[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "29": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * mainHashMask[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "30": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * mainHash[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "31": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * collCount[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "32": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * collEnd[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "33": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * longestCollisionList[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "34": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _length[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "35": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | MULT3[2]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "36": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | MULT3[1]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "37": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash ^= (hash << 7);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "38": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) || quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "39": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash -= ((hash * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "40": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * i[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "41": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | i[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "42": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nif((qlen < 3)){\ncontinue;\n}\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "43": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) && quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "44": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3[0]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "45": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) & quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "46": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += (hash >>> 3);\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "47": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * i) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "48": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | MULT3[0]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "49": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += (hash * MULT3);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "50": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nif((hash * MULT3)){\ncontinue;\n}\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "51": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) < quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "52": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * quads[2]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "53": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((MULT3[i] * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "54": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = (hash * MULT3);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "55": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * quads[1]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "56": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((quads[i] * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "57": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nif((i < qlen)){\ncontinue;\n}\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "58": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash[i] * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "59": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash ^= (hash << 7);\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "60": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | quads[2]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "61": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nbreak;\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "62": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash *= ((hash * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "63": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | MULT2[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "64": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | quads[1]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "65": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash *= MULT;\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "66": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash |= ((hash * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "67": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * DEFAULT_TABLE_SIZE) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "68": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MAX_TABLE_SIZE) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "69": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MAX_ENTRIES_FOR_REUSE) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "70": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MAX_COLL_CHAIN_LENGTH) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "71": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MAX_COLL_CHAIN_FOR_REUSE) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "72": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MIN_HASH_SIZE) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "73": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * INITIAL_COLLISION_LEN) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "74": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * LAST_VALID_BUCKET) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "75": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _hashSeed) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "76": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _count) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "77": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _longestCollisionList) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "78": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _mainHashMask) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "79": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _mainHash) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "80": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _collCount) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "81": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _collEnd) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "82": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "83": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT2) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "84": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * count) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "85": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * mainHashMask) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "86": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * mainHash) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "87": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * collCount) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "88": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * collEnd) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "89": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * longestCollisionList) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "90": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * _length) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "91": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3[((hash * MULT3) | quads[i])]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "92": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | i);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "93": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash *= MULT2;\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "94": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nfor(int i = 3;(i < qlen);++i) {            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "95": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += quads[1];\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "96": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += (hash >>> 15);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "97": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += (hash >>> 9);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "98": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += (hash >>> 17);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "99": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | MULT[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "100": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash ^= (hash << 9);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "101": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash *= MULT;\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "102": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * qlen[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "103": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((i[i] * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "104": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((i * MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "105": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash *= MULT2;\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "106": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash ^= (hash << 9);\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "107": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += quads[1];\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "108": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += (hash >>> 9);\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "109": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += (hash >>> 15);\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "110": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += (hash >>> 17);\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "111": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nreturn hash;            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "112": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) * quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "113": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) - quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "114": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) << quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "115": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) / quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "116": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) + quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "117": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nreturn;\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "118": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash - MULT3) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "119": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\ncontinue;\n            hash = (hash * MULT3) | quads[i];            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "120": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((hash * MULT3) | (MULT3[i] * quads));\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "121": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((MULT3[i] * quads) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "122": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((MULT3 * quads[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "123": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += ((hash * MULT3) | (MULT3[i] * quads));\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "124": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((MULT3 * MULT3[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "125": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((MULT3[i] * quads[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "126": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += ((hash * MULT3) | (MULT3 * quads[i]));\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "127": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += ((MULT3 * quads[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "128": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += ((MULT3[i] * quads[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "129": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = ((MULT3[i] * MULT3[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "130": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += ((MULT3[i] * MULT3[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "131": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash += ((hash * MULT3) | (MULT3[i] * quads[i]));\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }",
          "132": "    public int calcHash(int[] quads, int qlen)\n    {\n        // Note: may be called for qlen < 3; but has at least one int\n        if (qlen < 3) {\n            throw new IllegalArgumentException();\n        }\n\n        /* And then change handling again for \"multi-quad\" case; mostly\n         * to make calculation of collisions less fun. For example,\n         * add seed bit later in the game, and switch plus/xor around,\n         * use different shift lengths.\n         */\n        int hash = quads[0] ^ _hashSeed;\n        hash += (hash >>> 9);\n        hash *= MULT;\n        hash += quads[1];\n        hash *= MULT2;\n        hash += (hash >>> 15);\n        hash ^= quads[2];\n        hash += (hash >>> 17);\n        \n        for (int i = 3; i < qlen; ++i) {\nhash = (((MULT3 * MULT3) * quads[i]) | quads[i]);\n            // for longer entries, mess a bit in-between too\n            hash += (hash >>> 3);\n            hash ^= (hash << 7);\n        }\n        // and finally shuffle some more once done\n        hash += (hash >>> 15); // to get high-order bits to mix more\n        hash ^= (hash << 9); // as well as lowest 2 bytes\n        return hash;\n    }"
}