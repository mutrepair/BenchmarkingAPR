{
          "0": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(true){                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "1": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\n                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "2": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nreturn;\n            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "3": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(-false){                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "4": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nbreak;\n                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "5": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif((ignored != null)){\n            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n}\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "6": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(B.booleanValue()){\n                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "7": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(( != null)){\n            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n}\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "8": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif((ignored == null)){\nreturn;\n}            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "9": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(ignored){\n                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "10": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(-true){                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "11": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif((ignored != null)){\nreturn;\n}            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "12": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nbuilder.setIgnoreUnknownProperties(ignoreAny);\n            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "13": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(( != null)){\n            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n}\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "14": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif((ignored == null)){\n            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n}\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "15": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nignoreAny = B.booleanValue();\n            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "16": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(( == null)){\nreturn;\n}            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "17": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(( == null)){\nreturn;\n}            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "18": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(( != null)){\nreturn;\n}            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "19": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(1){                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "20": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(0){                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "21": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(false){                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "22": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nreturn;\nreturn;\n            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "23": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(((ignored != null) && (ignored != null))){\n                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "24": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(((ignored != null) && (ignored != null))){\nreturn;\n}            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "25": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(((ignored != null) && (ignored != null))){\n            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n}\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "26": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(((ignored != null) && (ignored == null))){\nreturn;\n}            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }",
          "27": "    protected void addBeanProps(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanDeserializerBuilder builder)\n        throws JsonMappingException\n    {\n        final SettableBeanProperty[] creatorProps =\n                builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n        \n        // Things specified as \"ok to ignore\"? [JACKSON-77]\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        boolean ignoreAny = false;\n        {\n            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\nif(((ignored != null) && ( != null))){\nreturn;\n}            if (true) {                ignoreAny = B.booleanValue();\n                builder.setIgnoreUnknownProperties(ignoreAny);\n            }\n        }\n        // Or explicit/implicit definitions?\n        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n        for (String propName : ignored) {\n            builder.addIgnorable(propName);\n        }\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n        if (anySetter != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n        // Implicit ones via @JsonIgnore and equivalent?\n        if (anySetter == null) {\n            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n            if (ignored2 != null) {\n                for (String propName : ignored2) {\n                    // allow ignoral of similarly named JSON property, but do not force;\n                    // latter means NOT adding this to 'ignored':\n                    builder.addIgnorable(propName);\n                }\n            }\n        }\n        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n\n        // Ok: let's then filter out property definitions\n        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                beanDesc, builder, beanDesc.findProperties(), ignored);\n\n        // After which we can let custom code change the set\n        if (_factoryConfig.hasDeserializerModifiers()) {\n            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n            }\n        }\n        \n        // At which point we still have all kinds of properties; not all with mutators:\n        for (BeanPropertyDefinition propDef : propDefs) {\n            SettableBeanProperty prop = null;\n            if (propDef.hasConstructorParameter()) {\n                /* [JACKSON-700] If property is passed via constructor parameter, we must\n                 *   handle things in special way. Not sure what is the most optimal way...\n                 *   for now, let's just call a (new) method in builder, which does nothing.\n                 */\n                // but let's call a method just to allow custom builders to be aware...\n                final String name = propDef.getName();\n                if (creatorProps != null) {\n                    for (SettableBeanProperty cp : creatorProps) {\n                        if (name.equals(cp.getName())) {\n                            prop = cp;\n                            break;\n                        }\n                    }\n                }\n                if (prop == null) {\n                    throw ctxt.mappingException(\"Could not find creator property with name '\"\n                    \t\t+name+\"' (in class \"+beanDesc.getBeanClass().getName()+\")\");\n                }\n                builder.addCreatorProperty(prop);\n                continue;\n            }\n            if (propDef.hasSetter()) {\n                Type propertyType = propDef.getSetter().getGenericParameterType(0);\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (propDef.hasField()) {\n                Type propertyType = propDef.getField().getGenericType();\n                prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n            } else if (useGettersAsSetters && propDef.hasGetter()) {\n                /* As per [JACKSON-88], may also need to consider getters\n                 * for Map/Collection properties; but with lowest precedence\n                 */\n                AnnotatedMethod getter = propDef.getGetter();\n                // should only consider Collections and Maps, for now?\n                Class<?> rawPropertyType = getter.getRawType();\n                if (Collection.class.isAssignableFrom(rawPropertyType)\n                        || Map.class.isAssignableFrom(rawPropertyType)) {\n                    prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                }\n            }\n            if (prop != null) {\n                Class<?>[] views = propDef.findViews();\n                if (views == null) {\n                    // one more twist: if default inclusion disabled, need to force empty set of views\n                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                        views = NO_VIEWS;\n                    }\n                }\n                // one more thing before adding to builder: copy any metadata\n                prop.setViews(views);\n                builder.addProperty(prop);\n            }\n        }\n    }"
}