{
          "0": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "1": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInArray(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "2": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "3": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(true);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "4": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn nextInArray(false);      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "5": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nbreak;\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "6": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nbeginArray();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "7": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nendArray();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "8": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nbeginObject();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "9": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nendObject();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "10": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nconsumeNonExecutePrefix();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "11": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nnextNull();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "12": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nclose();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "13": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nskipValue();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "14": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\ncheckLenient();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "15": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nskipToEndOfLine();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "16": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\ndecodeLiteral();\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "17": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn beginArray();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "18": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn endArray();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "19": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn beginObject();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "20": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn endObject();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "21": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn consumeNonExecutePrefix();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "22": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn nextNull();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "23": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn close();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "24": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn skipValue();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "25": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn checkLenient();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "26": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn skipToEndOfLine();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "27": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn decodeLiteral();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "28": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn token = JsonToken.END_DOCUMENT;      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "29": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject();    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "30": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn null;      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "31": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nhasToken = true;\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "32": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nsyntaxError(\"null\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "33": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn token = JsonToken.END_DOCUMENT;    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "34": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(lenient);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "35": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(hasToken);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "36": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(skipping);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "37": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn objectValue();      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "38": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\ncontinue;\n    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "39": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn nextInObject(false);      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "40": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn nextInArray(true);      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "41": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn token;      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "42": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn firstToken;      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "43": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(\"null\");    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "44": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn firstToken;    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "45": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn token;    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "46": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "47": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreplaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "48": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInArray(true);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "49": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\ncontinue;\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "50": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn;\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "51": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn objectValue();    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "52": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn syntaxError(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "53": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn hasToken;      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "54": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(token);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "55": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn lenient;      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "56": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn objectValue(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "57": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn replaceTop(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "58": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nbreak;\n    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "59": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(firstToken);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "60": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nhasToken = true;\nbreak;\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "61": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nbreak;\nbreak;\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "62": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(true, false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "63": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nreturn this;      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "64": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(true, true);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "65": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(JsonToken.lenient);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "66": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(JsonToken.hasToken);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "67": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(JsonToken.skipping);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "68": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nif(!isLenient()){\nreturn null;}      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "69": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nif(!hasNext()){\nreturn null;}      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "70": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nif(!nextBoolean()){\nreturn null;}      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "71": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nconsumeNonExecutePrefix();\n    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "72": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(false, false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "73": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nsyntaxError(\"null\");\n    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "74": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn quickPeek(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "75": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(false, true);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "76": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nif((token != null)){\n}\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "77": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nhasToken = true;\n    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "78": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(lenient, true);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "79": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(hasToken, true);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "80": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(skipping, true);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "81": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(lenient, false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "82": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(hasToken, false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "83": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn nextInObject(skipping, false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "84": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\nreturn;\n    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "85": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nif((firstToken != null)){\n}\n      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }",
          "86": "  private JsonToken quickPeek() throws IOException {\n    if (hasToken) {\n      return token;\n    }\n\n    switch (peekStack()) {\n    case EMPTY_DOCUMENT:\n      if (lenient) {\n        consumeNonExecutePrefix();\n      }\n      replaceTop(JsonScope.NONEMPTY_DOCUMENT);\n      JsonToken firstToken = nextValue();\n      if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) {\n        syntaxError(\"Expected JSON document to start with '[' or '{'\");\nif((token != null)){\nreturn null;}      }\n      return firstToken;\n    case EMPTY_ARRAY:\n      return nextInArray(true);\n    case NONEMPTY_ARRAY:\n      return nextInArray(false);\n    case EMPTY_OBJECT:\n      return nextInObject(false);    case DANGLING_NAME:\n      return objectValue();\n    case NONEMPTY_OBJECT:\n      return nextInObject(false);\n    case NONEMPTY_DOCUMENT:\n      try {\n        JsonToken token = nextValue();\n        if (lenient) {\n          return token;\n        }\n        throw syntaxError(\"Expected EOF\");\n      } catch (EOFException e) {\n        hasToken = true; // TODO: avoid throwing here?\n        return token = JsonToken.END_DOCUMENT;\n      }\n    case CLOSED:\n      throw new IllegalStateException(\"JsonReader is closed\");\n    default:\n      throw new AssertionError();\n    }\n  }\n\n  /**\n   * Consumes the non-execute prefix if it exists.\n   */\n  private void consumeNonExecutePrefix() throws IOException {\n    // fast forward through the leading whitespace\n    nextNonWhitespace();\n    pos--;\n    \n    if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n      return;\n    }\n    \n    for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\n      if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\n        return; // not a security token!\n      }\n    }\n    \n    // we consumed a security token!\n    pos += NON_EXECUTE_PREFIX.length;\n  }\n\n  /**\n   * Advances the cursor in the JSON stream to the next token.\n   */\n  private JsonToken advance() throws IOException {\n    quickPeek();\n\n    JsonToken result = token;\n    hasToken = false;\n    token = null;\n    value = null;\n    name = null;\n    return result;\n  }\n\n  /**\n   * Returns the next token, a {@link JsonToken#NAME property name}, and\n   * consumes it.\n   *\n   * @throws IOException if the next token in the stream is not a property\n   *     name.\n   */\n  public String nextName() throws IOException {\n    quickPeek();\n    if (token != JsonToken.NAME) {\n      throw new IllegalStateException(\"Expected a name but was \" + peek());\n    }\n    String result = name;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#STRING string} value of the next token,\n   * consuming it. If the next token is a number, this method will return its\n   * string form.\n   *\n   * @throws IllegalStateException if the next token is not a string or if\n   *     this reader is closed.\n   */\n  public String nextString() throws IOException {\n    peek();\n    if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) {\n      throw new IllegalStateException(\"Expected a string but was \" + peek());\n    }\n\n    String result = value;\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,\n   * consuming it.\n   *\n   * @throws IllegalStateException if the next token is not a boolean or if\n   *     this reader is closed.\n   */\n  public boolean nextBoolean() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek());\n    }\n\n    boolean result;\n    if (value.equalsIgnoreCase(\"true\")) {\n      result = true;\n    } else if (value.equalsIgnoreCase(\"false\")) {\n      result = false;\n    } else {\n      throw new IllegalStateException(\"Not a boolean: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Consumes the next token from the JSON stream and asserts that it is a\n   * literal null.\n   *\n   * @throws IllegalStateException if the next token is not null or if this\n   *     reader is closed.\n   */\n  public void nextNull() throws IOException {\n    quickPeek();\n    if (value == null || token == JsonToken.STRING) {\n      throw new IllegalStateException(\"Expected null but was \" + peek());\n    }\n\n    if (!value.equalsIgnoreCase(\"null\")) {\n      throw new IllegalStateException(\"Not a null: \" + value);\n    }\n\n    advance();\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER double} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a double.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a double, or is non-finite.\n   */\n  public double nextDouble() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a double but was \" + peek());\n    }\n\n    double result = Double.parseDouble(value);\n\n    if ((result >= 1.0d && value.startsWith(\"0\"))) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER long} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as a long. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code long}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as a long.\n   */\n  public long nextLong() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected a long but was \" + peek());\n    }\n\n    long result;\n    try {\n      result = Long.parseLong(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (long) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Returns the {@link JsonToken#NUMBER int} value of the next token,\n   * consuming it. If the next token is a string, this method will attempt to\n   * parse it as an int. If the next token's numeric value cannot be exactly\n   * represented by a Java {@code int}, this method throws.\n   *\n   * @throws IllegalStateException if the next token is not a literal value.\n   * @throws NumberFormatException if the next literal value cannot be parsed\n   *     as a number, or exactly represented as an int.\n   */\n  public int nextInt() throws IOException {\n    quickPeek();\n    if (value == null) {\n      throw new IllegalStateException(\"Expected an int but was \" + peek());\n    }\n\n    int result;\n    try {\n      result = Integer.parseInt(value);\n    } catch (NumberFormatException ignored) {\n      double asDouble = Double.parseDouble(value); // don't catch this NumberFormatException\n      result = (int) asDouble;\n      if ((double) result != asDouble) {\n        throw new NumberFormatException(value);\n      }\n    }\n\n    if (result >= 1L && value.startsWith(\"0\")) {\n      throw new NumberFormatException(\"JSON forbids octal prefixes: \" + value);\n    }\n\n    advance();\n    return result;\n  }\n\n  /**\n   * Closes this JSON reader and the underlying {@link Reader}.\n   */\n  public void close() throws IOException {\n    hasToken = false;\n    value = null;\n    token = null;\n    stack.clear();\n    stack.add(JsonScope.CLOSED);\n    in.close();\n  }\n\n  /**\n   * Skips the next value recursively. If it is an object or array, all nested\n   * elements are skipped. This method is intended for use when the JSON token\n   * stream contains unrecognized or unhandled values.\n   */\n  public void skipValue() throws IOException {\n    skipping = true;\n    try {\n      int count = 0;\n      do {\n        JsonToken token = advance();\n        if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {\n          count++;\n        } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {\n          count--;\n        }\n      } while (count != 0);\n    } finally {\n      skipping = false;\n    }\n  }\n\n  private JsonScope peekStack() {\n    return stack.get(stack.size() - 1);\n  }\n\n  private JsonScope pop() {\n    return stack.remove(stack.size() - 1);\n  }\n\n  private void push(JsonScope newTop) {\n    stack.add(newTop);\n  }\n\n  /**\n   * Replace the value on the top of the stack with the given value.\n   */\n  private void replaceTop(JsonScope newTop) {\n    stack.set(stack.size() - 1, newTop);\n  }\n\n  private JsonToken nextInArray(boolean firstElement) throws IOException {\n    if (firstElement) {\n      replaceTop(JsonScope.NONEMPTY_ARRAY);\n    } else {\n      /* Look for a comma before each element after the first element. */\n      switch (nextNonWhitespace()) {\n      case ']':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      case ';':\n        checkLenient(); // fall-through\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated array\");\n      }\n    }\n\n    switch (nextNonWhitespace()) {\n    case ']':\n      if (firstElement) {\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_ARRAY;\n      }\n      // fall-through to handle \",]\"\n    case ';':\n    case ',':\n      /* In lenient mode, a 0-length literal means 'null' */\n      checkLenient();\n      pos--;\n      hasToken = true;\n      value = \"null\";\n      return token = JsonToken.NULL;\n    default:\n      pos--;\n      return nextValue();\n    }\n  }\n\n  private JsonToken nextInObject(boolean firstElement) throws IOException {\n    /*\n     * Read delimiters. Either a comma/semicolon separating this and the\n     * previous name-value pair, or a close brace to denote the end of the\n     * object.\n     */\n    if (firstElement) {\n      /* Peek to see if this is the empty object. */\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      default:\n        pos--;\n      }\n    } else {\n      switch (nextNonWhitespace()) {\n      case '}':\n        pop();\n        hasToken = true;\n        return token = JsonToken.END_OBJECT;\n      case ';':\n      case ',':\n        break;\n      default:\n        throw syntaxError(\"Unterminated object\");\n      }\n    }"
}