{
          "0": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((bins % 1)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "1": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i >= (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "2": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((values[i] - minimum)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "3": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i + 1) * binWidth)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "4": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((maximum - minimum)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "5": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i + 1)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "6": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins >= 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "7": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i <= (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "8": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i > (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "9": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "10": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i != (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "11": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins <= 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "12": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bin % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "13": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins % 1))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "14": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((minimum + ((i + 1) * binWidth))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "15": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins == 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "16": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nreturn;\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "17": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nupper = (minimum + ((i + 1) * binWidth));\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "18": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins > 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "19": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbin = new HistogramBin(lower, upper);\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "20": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((bin != null)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "21": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i == (bins % 1)) || (maximum - minimum))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "22": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i < (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "23": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i != null)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "24": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nfraction = 0.0;\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "25": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nlower = upper;\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "26": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins != 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "27": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(i){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "28": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i - (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "29": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins % 0))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "30": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbinIndex = (bins - 1);\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "31": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbinList.add(bin);\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "32": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (maximum % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "33": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (minimum % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "34": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "35": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbinIndex = (int)(fraction * bins);\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "36": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbin = new HistogramBin(lower, maximum);\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "37": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((values[i] - minimum)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "38": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((bins % 1)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "39": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (binIndex % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "40": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((bins - 1)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "41": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i == (bins % 1)) || (i == (bins % 1)))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "42": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((bin == (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "43": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i >> (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "44": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i + 1) * binWidth)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "45": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (fraction % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "46": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i == (bins % 1)) && (maximum - minimum))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "47": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbin.incrementCount();\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "48": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (i % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "49": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i + 1)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "50": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((fraction * bins)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "51": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins - 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "52": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((maximum - minimum)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "53": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == null)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "54": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((fraction < 0.0)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "55": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i >>> (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "56": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((bin == null)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "57": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins < 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "58": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((values[i] < maximum)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "59": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((values[i] < maximum)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "60": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nfor(int i = 0;(i < values.length);i++) {            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "61": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbreak;\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "62": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins >> 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "63": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i + (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "64": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((fraction < 0.0)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "65": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((maximum == (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "66": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((minimum == (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "67": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins % 2))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "68": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins >>> 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "69": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((binIndex >= bins)){\n            if (i == bins % 1) {                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n}\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "70": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((binIndex == (bins % 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "71": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((binIndex >= bins)){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "72": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbinIndex = (bins - 1);\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "73": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i != null) && (i == (bins % 1)))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "74": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nfraction = 0.0;\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "75": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i != null) || (i == (bins % 1)))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "76": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i == null) || (i == (bins % 1)))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "77": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i == (bins % 1)) || (i > 0))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "78": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif((i == (bins + 1))){                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "79": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i == (bins % 1)) || (i > i))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "80": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i == (bins % 1)) || (i < 0))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "81": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nupper = (minimum + ((i + 1) * binWidth));\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "82": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i == (bins % 1)) || (i > 1))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "83": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbin = new HistogramBin(lower, maximum);\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "84": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nif(((i == (bins % 1)) || (i < i))){\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }",
          "85": "    public void addSeries(Comparable key,\n                          double[] values,\n                          int bins,\n                          double minimum,\n                          double maximum) {\n\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Null 'values' argument.\");\n        }\n        else if (bins < 1) {\n            throw new IllegalArgumentException(\n                    \"The 'bins' value must be at least 1.\");\n        }\n        double binWidth = (maximum - minimum) / bins;\n\n        double lower = minimum;\n        double upper;\n        List binList = new ArrayList(bins);\n        for (int i = 0; i < bins; i++) {\n            HistogramBin bin;\n            // make sure bins[bins.length]'s upper boundary ends at maximum\n            // to avoid the rounding issue. the bins[0] lower boundary is\n            // guaranteed start from min\nbin = new HistogramBin(lower, upper);\n                bin = new HistogramBin(lower, maximum);\n            }\n            else {\n                upper = minimum + (i + 1) * binWidth;\n                bin = new HistogramBin(lower, upper);\n                lower = upper;\n            }\n            binList.add(bin);\n        }\n        // fill the bins\n        for (int i = 0; i < values.length; i++) {\n            int binIndex = bins - 1;\n            if (values[i] < maximum) {\n                double fraction = (values[i] - minimum) / (maximum - minimum);\n                if (fraction < 0.0) {\n                    fraction = 0.0;\n                }\n                binIndex = (int) (fraction * bins);\n                // rounding could result in binIndex being equal to bins\n                // which will cause an IndexOutOfBoundsException - see bug\n                // report 1553088\n                if (binIndex >= bins) {\n                    binIndex = bins - 1;\n                }\n            }\n            HistogramBin bin = (HistogramBin) binList.get(binIndex);\n            bin.incrementCount();\n        }\n        // generic map for each series\n        Map map = new HashMap();\n        map.put(\"key\", key);\n        map.put(\"bins\", binList);\n        map.put(\"values.length\", new Integer(values.length));\n        map.put(\"bin width\", new Double(binWidth));\n        this.list.add(map);\n    }"
}