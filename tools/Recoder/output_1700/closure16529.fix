{
          "0": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(false){\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "1": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nensureGenerated();\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "2": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nprocess();\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "3": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nsetDeclaredType();\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "4": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(hasExternsRoot()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "5": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isTypeInferred()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "6": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(canEliminate()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "7": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isSimpleStubDeclaration()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "8": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(canCollapse()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "9": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isGetOrSetDefinition()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "10": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(canCollapseUnannotatedChildNames()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "11": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(shouldKeepKeys()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "12": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(needsToBeStubbed()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "13": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isDeclaredType()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "14": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isNamespace()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "15": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isSimpleName()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "16": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isSet()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "17": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nreturn;\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "18": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!hasExternsRoot()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "19": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isTypeInferred()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "20": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!canEliminate()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "21": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isSimpleStubDeclaration()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "22": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!canCollapse()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "23": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isGetOrSetDefinition()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "24": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!canCollapseUnannotatedChildNames()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "25": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!shouldKeepKeys()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "26": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!needsToBeStubbed()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "27": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isDeclaredType()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "28": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isNamespace()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "29": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isSimpleName()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "30": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isSet()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "31": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(n){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "32": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(hasExternsRoot()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "33": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isTypeInferred()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "34": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(canEliminate()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "35": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isSimpleStubDeclaration()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "36": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(canCollapse()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "37": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isGetOrSetDefinition()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "38": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(canCollapseUnannotatedChildNames()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "39": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(shouldKeepKeys()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "40": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(needsToBeStubbed()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "41": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isDeclaredType()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "42": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isNamespace()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "43": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isSimpleName()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "44": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(isSet()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "45": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!hasExternsRoot()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "46": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isTypeInferred()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "47": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!canEliminate()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "48": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isSimpleStubDeclaration()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "49": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!canCollapse()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "50": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isGetOrSetDefinition()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "51": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!canCollapseUnannotatedChildNames()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "52": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!shouldKeepKeys()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "53": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!needsToBeStubbed()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "54": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isDeclaredType()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "55": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isNamespace()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "56": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isSimpleName()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "57": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!isSet()){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "58": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((parent == null)){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "59": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(t){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "60": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nRef.ensureGenerated();\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "61": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nRef.process();\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "62": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nRef.setDeclaredType();\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "63": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((n == null)){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "64": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!n){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "65": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(parent){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "66": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nsuper.handleSetFromGlobal();\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "67": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(currentPreOrderIndex){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "68": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((parent != null)){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "69": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((parent != null)){\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n}\n    }",
          "70": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((name == null)){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "71": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((n != null)){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "72": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(nameObj){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "73": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!parent){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "74": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((n != null)){\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n}\n    }",
          "75": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(-false){\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "76": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!currentPreOrderIndex){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "77": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(!t){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "78": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((parent == null)){\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n}\n    }",
          "79": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(parent.isEmpty()){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "80": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((name != null)){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "81": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((n == null)){\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n}\n    }",
          "82": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((t == null)){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "83": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((name != null)){\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n}\n    }",
          "84": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nnameObj.setDeclaredType();\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "85": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nnameObj.addRef(get);\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "86": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nRef.markTwins(set, get);\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "87": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((name == null)){\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n}\n    }",
          "88": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((t != null)){\nreturn;\n}      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "89": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nbreak;\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "90": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nnameObj.addRef(set);\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "91": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\ncontinue;\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "92": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((t != null)){\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n}\n    }",
          "93": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nnameObj.type = type;\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "94": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(\"null\"){\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "95": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(1){\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "96": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((n || (name == null))){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "97": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((parent || (isPropAssign == null))){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "98": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((parent || (name == null))){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "99": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif(null){\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "100": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((n || (parent == null))){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "101": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((parent || (parent == null))){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "102": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nbreak;\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "103": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((n && (name == null))){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "104": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((n || (isPropAssign == null))){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "105": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nif((parent && (isPropAssign == null))){\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "106": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }",
          "107": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\nreturn;\nreturn;\n      if (true) return;\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isTypeDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setDeclaredType();\n      }\n    }"
}