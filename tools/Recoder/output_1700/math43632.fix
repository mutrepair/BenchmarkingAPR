{
          "0": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nr = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "1": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\ntheta = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "2": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nphi = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "3": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\njacobian = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "4": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "5": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nthetaHessian = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "6": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nphiHessian = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "7": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nx = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "8": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\ny = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "9": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nz = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "10": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "11": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nr[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "12": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\ntheta[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "13": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nphi[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "14": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\njacobian[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "15": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nthetaHessian[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "16": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nphiHessian[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "17": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nx[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "18": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\ny[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "19": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nz[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "20": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z * rHessian));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "21": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z * rHessian[0].[0]));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "22": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z * zOr3[0]));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "23": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (z * zOr3);\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "24": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian = (z * zOr3);\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "25": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (y * yOr3);\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "26": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (r * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "27": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (theta * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "28": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (phi * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "29": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (jacobian * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "30": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (rHessian * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "31": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (thetaHessian * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "32": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (phiHessian * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "33": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (x * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "34": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (y * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "35": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nzOr3[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "36": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z * rHessian[0]));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "37": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian = (y * yOr3);\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "38": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z * zOr3[0].[0]));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "39": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (r[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "40": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (theta[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "41": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (phi[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "42": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (jacobian[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "43": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (rHessian[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "44": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (thetaHessian[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "45": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (phiHessian[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "46": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (x[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "47": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (y[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "48": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z[0].[0] * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "49": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * rHessian[0].[0]) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "50": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * rHessian) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "51": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) + (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "52": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nzOr3[0].[0] = ((y * yOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "53": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z - zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "54": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z * yOr3[0].[0]));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "55": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (z * yOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "56": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) / (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "57": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) | (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "58": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[1].[0] = (-x * yOr3);\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "59": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian = new double[3];\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "60": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((zOr3 * zOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "61": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (zOr3 * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "62": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((zOr3 * zOr3) / (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "63": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((zOr3 * zOr3) + (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "64": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nreturn;\n            rHessian[0][0] = y * yOr3 * (z * zOr3);            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "65": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (((zOr3 * zOr3) * zOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "66": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (((zOr3 * zOr3) * (z * zOr3)) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "67": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (((zOr3 * zOr3) * zOr3) / (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "68": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (((zOr3 * zOr3) * zOr3) + (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "69": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (((y * yOr3) * (zOr3 * zOr3)) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "70": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (((zOr3 * zOr3) * (z * zOr3)) + (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "71": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (((zOr3 * zOr3) * (z * zOr3)) / (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "72": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * ((zOr3 * zOr3) * (z * zOr3)));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "73": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * ((zOr3 * zOr3) * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "74": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (zOr3 * (zOr3 * zOr3)));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "75": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\n            rHessian[0][0] = y * yOr3 * (z * zOr3);            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "76": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((((zOr3 * zOr3) * zOr3) * (z * zOr3)) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "77": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((((zOr3 * zOr3) * (z * zOr3)) * (z * zOr3)) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "78": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (((y * yOr3) * ((zOr3 * zOr3) * zOr3)) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "79": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((((zOr3 * 1) * (z * zOr3)) * (z * zOr3)) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "80": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((((zOr3 * zOr3) * zOr3) * zOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "81": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (((zOr3 * zOr3) * zOr3) * (z * zOr3)));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "82": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((((zOr3 * zOr3) * (z * zOr3)) * zOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "83": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((((zOr3 * 1) * zOr3) * (z * zOr3)) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "84": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((y * yOr3) * (((zOr3 * zOr3) * zOr3) * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "85": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = ((((zOr3 * 1) * zOr3) * zOr3) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }",
          "86": "    private void computeHessians() {\n\n        if (rHessian == null) {\n\n            // intermediate variables\n            final double x      = v.getX();\n            final double y      = v.getY();\n            final double z      = v.getZ();\n            final double x2     = x * x;\n            final double y2     = y * y;\n            final double z2     = z * z;\n            final double rho2   = x2 + y2;\n            final double rho    = FastMath.sqrt(rho2);\n            final double r2     = rho2 + z2;\n            final double xOr    = x / r;\n            final double yOr    = y / r;\n            final double zOr    = z / r;\n            final double xOrho2 = x / rho2;\n            final double yOrho2 = y / rho2;\n            final double xOr3   = xOr / r2;\n            final double yOr3   = yOr / r2;\n            final double zOr3   = zOr / r2;\n\n            // lower-left part of Hessian of r\n            rHessian = new double[3][3];\nrHessian[0].[0] = (((((zOr3 * zOr3) * zOr3) * zOr3) * (z * zOr3)) * (z * zOr3));\n            rHessian[1][0] = -x * yOr3;\n            rHessian[2][0] = -z * xOr3;\n            rHessian[1][1] = x * xOr3 + z * zOr3;\n            rHessian[2][1] = -y * zOr3;\n            rHessian[2][2] = x * xOr3 + y * yOr3;\n\n            // upper-right part is symmetric\n            rHessian[0][1] = rHessian[1][0];\n            rHessian[0][2] = rHessian[2][0];\n            rHessian[1][2] = rHessian[2][1];\n\n            // lower-left part of Hessian of azimuthal angle theta\n            thetaHessian = new double[2][2];\n            thetaHessian[0][0] = 2 * xOrho2 * yOrho2;\n            thetaHessian[1][0] = yOrho2 * yOrho2 - xOrho2 * xOrho2;\n            thetaHessian[1][1] = -2 * xOrho2 * yOrho2;\n\n            // upper-right part is symmetric\n            thetaHessian[0][1] = thetaHessian[1][0];\n\n            // lower-left part of Hessian of polar (co-latitude) angle phi\n            final double rhor2       = rho * r2;\n            final double rho2r2      = rho * rhor2;\n            final double rhor4       = rhor2 * r2;\n            final double rho3r4      = rhor4 * rho2;\n            final double r2P2rho2    = 3 * rho2 + z2;\n            phiHessian = new double[3][3];\n            phiHessian[0][0] = z * (rho2r2 - x2 * r2P2rho2) / rho3r4;\n            phiHessian[1][0] = -x * y * z * r2P2rho2 / rho3r4;\n            phiHessian[2][0] = x * (rho2 - z2) / rhor4;\n            phiHessian[1][1] = z * (rho2r2 - y2 * r2P2rho2) / rho3r4;\n            phiHessian[2][1] = y * (rho2 - z2) / rhor4;\n            phiHessian[2][2] = 2 * rho * zOr3 / r;\n\n            // upper-right part is symmetric\n            phiHessian[0][1] = phiHessian[1][0];\n            phiHessian[0][2] = phiHessian[2][0];\n            phiHessian[1][2] = phiHessian[2][1];\n\n        }\n\n    }"
}